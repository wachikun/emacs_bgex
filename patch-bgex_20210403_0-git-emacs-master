diff --git a/src/dispextern.h b/src/dispextern.h
index f4e872644d..1899057506 100644
--- a/src/dispextern.h
+++ b/src/dispextern.h
@@ -2958,7 +2958,7 @@ reset_mouse_highlight (Mouse_HLInfo *hlinfo)
   void (*define_frame_cursor) (struct frame *f, Emacs_Cursor cursor);
 
   /* Clear the area at (X,Y,WIDTH,HEIGHT) of frame F.  */
-  void (*clear_frame_area) (struct frame *f, int x, int y,
+  void (*clear_frame_area) (struct window *w, struct frame *f, int x, int y,
                             int width, int height);
 
  /* Clear area of frame F's internal border.  If the internal border
diff --git a/src/dispnew.c b/src/dispnew.c
index f613f7b656..49709d9944 100644
--- a/src/dispnew.c
+++ b/src/dispnew.c
@@ -233,6 +233,7 @@ #define WINDOW_TO_FRAME_HPOS(W, HPOS) ((HPOS) + WINDOW_LEFT_EDGE_COL (W))
 
 #endif /* GLYPH_DEBUG */
 
+extern int bgexi_p (int bgexid);
 
 #if defined PROFILING && !HAVE___EXECUTABLE_START
 /* This function comes first in the Emacs executable and is used only
@@ -4451,6 +4452,8 @@ scrolling_window (struct window *w, int tab_line_p)
   if (w32_use_visible_system_caret)
     return 0;
 #endif
+  if (bgexi_p (-1))
+    return 0;
 
   /* Give up if some rows in the desired matrix are not enabled.  */
   if (! MATRIX_ROW_ENABLED_P (desired_matrix, i))
diff --git a/src/frame.h b/src/frame.h
index 9ddcb4c681..cb881d09f9 100644
--- a/src/frame.h
+++ b/src/frame.h
@@ -256,6 +256,9 @@ #define EMACS_FRAME_H
      be used for output.  */
   bool_bf glyphs_initialized_p : 1;
 
+  int bgexi_background_pixmap_initialized_p;
+  int bgexi_background_pixmap_p;
+
   /* Set to true in change_frame_size when size of frame changed
      Clear the frame in clear_garbaged_frames if set.  */
   bool_bf resized_p : 1;
diff --git a/src/ftcrfont.c b/src/ftcrfont.c
index db417b3e77..1c5d575b0c 100644
--- a/src/ftcrfont.c
+++ b/src/ftcrfont.c
@@ -22,6 +22,7 @@
 #include <cairo-ft.h>
 
 #include "lisp.h"
+#include "frame.h"
 #include "xterm.h"
 #include "blockinput.h"
 #include "charset.h"
@@ -30,6 +31,16 @@
 #include "ftfont.h"
 #include "pdumper.h"
 
+extern int bgexi_p (int bgexid);
+extern int bgexi_fast_p (void);
+extern int bgexi_only_fast_p (void);
+extern int bgexi_get_dynamic_color_flag (int bgexid);
+extern int bgexi_get_enable_bgexid (struct window *window);
+extern int bgexi_clear_special_trigger_p (void);
+extern int bgexi_fill_rectangle (GC gc, struct window *window,
+                                 int x, int y, int w, int h, int *rgba);
+extern int bgexi_overstrike_p (void);
+
 #define METRICS_NCOLS_PER_ROW	(128)
 
 enum metrics_status
@@ -515,12 +526,95 @@ ftcrfont_draw (struct glyph_string *s,
 
   cr = x_begin_cr_clip (f, s->gc);
 
-  if (with_background)
+  if (bgexi_p (-1) &&
+      !bgexi_overstrike_p())
+    {
+      XGCValues xgcv;
+      int draw_rect_p = 0;
+      int fill_rect_p = 0;
+      XGetGCValues (FRAME_X_DISPLAY (s->f), s->gc, GCBackground, &xgcv);
+      if (bgexi_only_fast_p () ||
+          (bgexi_fast_p () && (bgexi_get_enable_bgexid (s->w) == 0)))
+        {
+          if (bgexi_get_dynamic_color_flag (0))
+            {
+              if (FRAME_BACKGROUND_PIXEL (s->f) == xgcv.background)
+                {
+                  bgexi_fill_rectangle (s->gc, s->w, x, y - FONT_BASE (face->font), s->width, FONT_HEIGHT (face->font), 0);
+                }
+              else
+                {
+                  fill_rect_p = !0;
+                }
+            }
+          else
+            {
+              if (FRAME_BACKGROUND_PIXEL (s->f) == xgcv.background)
+                {
+                  bgexi_fill_rectangle (s->gc, s->w, x, y - FONT_BASE (face->font), s->width, FONT_HEIGHT (face->font), 0);
+                }
+              else
+                {
+                  fill_rect_p = !0;
+                }
+            }
+        }
+      else
+        {
+          if (FRAME_BACKGROUND_PIXEL (s->f) == xgcv.background)
+            {
+              if (bgexi_fill_rectangle (s->gc, s->w, x, y - FONT_BASE (face->font), s->width, FONT_HEIGHT (face->font), 0))
+                {
+                  draw_rect_p = !0;
+                }
+              else
+                {
+                }
+            }
+          else
+            {
+              fill_rect_p = !0;
+            }
+        }
+      if (fill_rect_p)
+        {
+          int rgba[4];
+          XColor xcolor;
+          xcolor.pixel = xgcv.background;
+          XQueryColor (FRAME_X_DISPLAY (s->f), FRAME_X_COLORMAP (s->f), &xcolor);
+          rgba[0] = xcolor.red;
+          rgba[1] = xcolor.green;
+          rgba[2] = xcolor.blue;
+          rgba[3] = 0;
+          if (s->face->box_horizontal_line_width == 0)
+            {
+              if ((xgcv.background == 0) ||
+                  bgexi_fill_rectangle (s->gc, s->w, x, y - FONT_BASE (face->font), s->width, FONT_HEIGHT (face->font), rgba))
+                {
+                  draw_rect_p = !0;
+                }
+              else
+                {
+                }
+            }
+        }
+      if (draw_rect_p && with_background)
+	{
+	  x_set_cr_source_with_gc_background (f, s->gc);
+	  cairo_rectangle (cr, x, y - FONT_BASE (face->font),
+			   s->width, FONT_HEIGHT (face->font));
+	  cairo_fill (cr);
+	}
+    }
+  else
     {
-      x_set_cr_source_with_gc_background (f, s->gc);
-      cairo_rectangle (cr, x, y - FONT_BASE (face->font),
-		       s->width, FONT_HEIGHT (face->font));
-      cairo_fill (cr);
+      if (with_background)
+	{
+	  x_set_cr_source_with_gc_background (f, s->gc);
+	  cairo_rectangle (cr, x, y - FONT_BASE (face->font),
+			   s->width, FONT_HEIGHT (face->font));
+	  cairo_fill (cr);
+	}
     }
 
   glyphs = alloca (sizeof (cairo_glyph_t) * len);
diff --git a/src/gtkutil.c b/src/gtkutil.c
index 4634c35dd4..4943911daf 100644
--- a/src/gtkutil.c
+++ b/src/gtkutil.c
@@ -4004,7 +4004,7 @@ xg_update_scrollbar_pos (struct frame *f,
           /* Clear under old scroll bar position.  */
           oldw += (scale - 1) * oldw;
 	  oldx -= (scale - 1) * oldw;
-          x_clear_area (f, oldx, oldy, oldw, oldh);
+          x_clear_area (0, f, oldx, oldy, oldw, oldh);
         }
 
       if (!hidden)
@@ -4081,7 +4081,7 @@ xg_update_horizontal_scrollbar_pos (struct frame *f,
         }
       if (oldx != -1 && oldw > 0 && oldh > 0)
         /* Clear under old scroll bar position.  */
-        x_clear_area (f, oldx, oldy, oldw, oldh);
+        x_clear_area (0, f, oldx, oldy, oldw, oldh);
 
       /* GTK does not redraw until the main loop is entered again, but
          if there are no X events pending we will not enter it.  So we sync
diff --git a/src/window.c b/src/window.c
index 4d5c7e763e..ce1225d0bb 100644
--- a/src/window.c
+++ b/src/window.c
@@ -110,6 +110,8 @@
 /* Same for window_scroll_line_based.  */
 static EMACS_INT window_scroll_preserve_hpos;
 static EMACS_INT window_scroll_preserve_vpos;
+
+extern void bgexi_redraw_all (void);
 
 static void
 CHECK_WINDOW_CONFIGURATION (Lisp_Object x)
@@ -3977,6 +3979,8 @@ set_window_buffer (Lisp_Object window, Lisp_Object buffer,
   ptrdiff_t count = SPECPDL_INDEX ();
   bool samebuf = EQ (buffer, w->contents);
 
+  w->bgexi_redisplay_p = 1;
+
   wset_buffer (w, buffer);
 
   if (EQ (window, selected_window))
@@ -6887,6 +6891,8 @@ DEFUN ("set-window-configuration", Fset_window_configuration,
   ptrdiff_t old_point = -1;
   USE_SAFE_ALLOCA;
 
+  bgexi_redraw_all ();
+
   CHECK_WINDOW_CONFIGURATION (configuration);
 
   data = (struct save_window_data *) XVECTOR (configuration);
diff --git a/src/window.h b/src/window.h
index b6f88e8f55..9495577b40 100644
--- a/src/window.h
+++ b/src/window.h
@@ -441,6 +441,9 @@ #define WINDOW_H_INCLUDED
     /* True if it needs to be redisplayed.  */
     bool_bf redisplay : 1;
 
+    /* BGEX flag. */
+    bool_bf bgexi_redisplay_p : 1;
+
     /* True if auto hscrolling is currently suspended in this
        window.  */
     bool_bf suspend_auto_hscroll : 1;
diff --git a/src/xdisp.c b/src/xdisp.c
index a405d51f80..1660fef87e 100644
--- a/src/xdisp.c
+++ b/src/xdisp.c
@@ -2936,6 +2936,14 @@ hscrolling_current_line_p (struct window *w)
 		 Qcurrent_line));
 }
 
+
+extern bool expose_window (struct window *w, const Emacs_Rectangle *fr);
+extern int bgexi_p (int bgexid);
+extern int bgexi_fast_p (void);
+extern int bgexi_only_fast_p (void);
+extern int bgexi_fill_rectangle (GC gc, struct window *window,
+                                 int x, int y, int w, int h, int *rgba);
+
 /***********************************************************************
 			Lisp form evaluation
  ***********************************************************************/
@@ -18461,6 +18469,18 @@ redisplay_window (Lisp_Object window, bool just_this_one_p)
   if (mode_line_update_needed (w))
     update_mode_line = true;
 
+  if (!just_this_one_p)
+    {
+      if (bgexi_p (-1) && !bgexi_only_fast_p () && w->bgexi_redisplay_p)
+        {
+          block_input ();
+          w->bgexi_redisplay_p = 0;
+          do_pending_window_change(1);
+          clear_current_matrices (f);
+          unblock_input ();
+        }
+    }
+
   /* Point refers normally to the selected window.  For any other
      window, set up appropriate value.  */
   if (!EQ (window, selected_window))
@@ -31232,7 +31252,7 @@ gui_clear_end_of_line (struct window *w, struct glyph_row *updated_row,
   if (to_x > from_x && to_y > from_y)
     {
       block_input ();
-      FRAME_RIF (f)->clear_frame_area (f, from_x, from_y,
+      FRAME_RIF (f)->clear_frame_area (w, f, from_x, from_y,
                                        to_x - from_x, to_y - from_y);
       unblock_input ();
     }
@@ -31758,7 +31778,7 @@ erase_phys_cursor (struct window *w)
       x = WINDOW_TEXT_TO_FRAME_PIXEL_X (w, x);
 
       if (width > 0)
-	FRAME_RIF (f)->clear_frame_area (f, x, y, width, cursor_row->visible_height);
+	FRAME_RIF (f)->clear_frame_area (w, f, x, y, width, cursor_row->visible_height);
     }
 
   /* Erase the cursor by redrawing the character underneath it.  */
@@ -34344,7 +34364,7 @@ gui_draw_bottom_divider (struct window *w)
    input blocked.  Value is true if the exposure overwrites
    mouse-face.  */
 
-static bool
+bool
 expose_window (struct window *w, const Emacs_Rectangle *fr)
 {
   struct frame *f = XFRAME (w->frame);
@@ -34382,6 +34402,14 @@ expose_window (struct window *w, const Emacs_Rectangle *fr)
       redisplay_trace ("expose_window (%d, %d, %u, %u)\n",
 		       r.x, r.y, r.width, r.height);
 
+      if (bgexi_p (-1) && !bgexi_only_fast_p ())
+        {
+          Display *dpy = FRAME_X_DISPLAY (f);
+          GC gc = XCreateGC (dpy, FRAME_X_DRAWABLE (f), 0, 0);
+          bgexi_fill_rectangle (gc, w, r.x, r.y, r.width, r.height, 0);
+          XFreeGC (dpy, gc);
+        }
+
       /* Convert to window coordinates.  */
       r.x -= WINDOW_LEFT_EDGE_X (w);
       r.y -= WINDOW_TOP_EDGE_Y (w);
diff --git a/src/xfns.c b/src/xfns.c
index 0507dc8f61..a46b84ed8a 100644
--- a/src/xfns.c
+++ b/src/xfns.c
@@ -21,6 +21,13 @@ Copyright (C) 1989, 1992-2021 Free Software Foundation, Inc.
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
+#if HAVE_PNG
+#if defined HAVE_LIBPNG_PNG_H
+#include <libpng/png.h>
+#else
+#include <png.h>
+#endif
+#endif
 #include <unistd.h>
 
 #include "lisp.h"
@@ -546,165 +553,3919 @@ x_real_pos_and_offsets (struct frame *f,
       unsigned int ign;
       Window rootw;
 
-      XGetGeometry (dpy, FRAME_OUTER_WINDOW (f),
-		    &rootw, &xy_ign, &xy_ign, &fw, &fh, &ign, &ign);
-#endif
+      XGetGeometry (dpy, FRAME_OUTER_WINDOW (f),
+		    &rootw, &xy_ign, &xy_ign, &fw, &fh, &ign, &ign);
+#endif
+    }
+
+#ifndef USE_XCB
+  x_uncatch_errors ();
+#endif
+
+  unblock_input ();
+
+  if (had_errors) return;
+
+  if (x_pixels_diff) *x_pixels_diff = -win_x;
+  if (y_pixels_diff) *y_pixels_diff = -win_y;
+
+  if (left_offset_x) *left_offset_x = -outer_x;
+  if (top_offset_y) *top_offset_y = -outer_y;
+
+  if (xptr) *xptr = real_x;
+  if (yptr) *yptr = real_y;
+
+  if (outer_border) *outer_border = bw;
+
+  if (right_offset_x) *right_offset_x = ow - fw + outer_x;
+  if (bottom_offset_y) *bottom_offset_y = oh - fh + outer_y;
+}
+
+/* Store the screen positions of frame F into XPTR and YPTR.
+   These are the positions of the containing window manager window,
+   not Emacs's own window.  */
+
+void
+x_real_positions (struct frame *f, int *xptr, int *yptr)
+{
+  x_real_pos_and_offsets (f, NULL, NULL, NULL, NULL, NULL, NULL, xptr, yptr,
+                          NULL);
+}
+
+
+/* Get the mouse position in frame relative coordinates.  */
+
+void
+x_relative_mouse_position (struct frame *f, int *x, int *y)
+{
+  Window root, dummy_window;
+  int dummy;
+
+  eassert (FRAME_X_P (f));
+
+  block_input ();
+
+  XQueryPointer (FRAME_X_DISPLAY (f),
+                 DefaultRootWindow (FRAME_X_DISPLAY (f)),
+
+                 /* The root window which contains the pointer.  */
+                 &root,
+
+                 /* Window pointer is on, not used  */
+                 &dummy_window,
+
+                 /* The position on that root window.  */
+                 x, y,
+
+                 /* x/y in dummy_window coordinates, not used.  */
+                 &dummy, &dummy,
+
+                 /* Modifier keys and pointer buttons, about which
+                    we don't care.  */
+                 (unsigned int *) &dummy);
+
+  XTranslateCoordinates (FRAME_X_DISPLAY (f),
+
+                         /* From-window, to-window.  */
+                         FRAME_DISPLAY_INFO (f)->root_window,
+                         FRAME_X_WINDOW (f),
+
+                         /* From-position, to-position.  */
+                         *x, *y, x, y,
+
+                         /* Child of win.  */
+                         &dummy_window);
+
+  unblock_input ();
+}
+
+/* Gamma-correct COLOR on frame F.  */
+
+void
+gamma_correct (struct frame *f, XColor *color)
+{
+  if (f->gamma)
+    {
+      color->red = pow (color->red / 65535.0, f->gamma) * 65535.0 + 0.5;
+      color->green = pow (color->green / 65535.0, f->gamma) * 65535.0 + 0.5;
+      color->blue = pow (color->blue / 65535.0, f->gamma) * 65535.0 + 0.5;
+    }
+}
+
+
+/* Decide if color named COLOR_NAME is valid for use on frame F.  If
+   so, return the RGB values in COLOR.  If ALLOC_P,
+   allocate the color.  Value is false if COLOR_NAME is invalid, or
+   no color could be allocated.  */
+
+bool
+x_defined_color (struct frame *f, const char *color_name,
+		 Emacs_Color *color, bool alloc_p, bool _makeIndex)
+{
+  bool success_p = false;
+  Colormap cmap = FRAME_X_COLORMAP (f);
+
+  block_input ();
+#ifdef USE_GTK
+  success_p = xg_check_special_colors (f, color_name, color);
+#endif
+  if (!success_p)
+    success_p = x_parse_color (f, color_name, color) != 0;
+  if (success_p && alloc_p)
+    success_p = x_alloc_nearest_color (f, cmap, color);
+  unblock_input ();
+
+  return success_p;
+}
+
+
+/* Return the pixel color value for color COLOR_NAME on frame F.  If F
+   is a monochrome frame, return MONO_COLOR regardless of what ARG says.
+   Signal an error if color can't be allocated.  */
+
+static int
+x_decode_color (struct frame *f, Lisp_Object color_name, int mono_color)
+{
+  XColor cdef;
+
+  CHECK_STRING (color_name);
+
+#if false /* Don't do this.  It's wrong when we're not using the default
+	     colormap, it makes freeing difficult, and it's probably not
+	     an important optimization.  */
+  if (strcmp (SDATA (color_name), "black") == 0)
+    return BLACK_PIX_DEFAULT (f);
+  else if (strcmp (SDATA (color_name), "white") == 0)
+    return WHITE_PIX_DEFAULT (f);
+#endif
+
+  /* Return MONO_COLOR for monochrome frames.  */
+  if (FRAME_DISPLAY_INFO (f)->n_planes == 1)
+    return mono_color;
+
+  /* x_defined_color is responsible for coping with failures
+     by looking for a near-miss.  */
+  if (x_defined_color (f, SSDATA (color_name), &cdef, true, false))
+    return cdef.pixel;
+
+  signal_error ("Undefined color", color_name);
+}
+
+
+/*
+
+  BGEX
+
+ */
+#define BGEXI_DBP(p,args...)
+/* #define BGEXI_DBP(p,args...) fprintf (stderr,"%s:%d  ",__FILE__,__LINE__);fprintf (stderr,p, ## args) */
+/* #define BGEXI_DBP_2(p,args...) */
+/* #define BGEXI_DBP_2(p,args...) fprintf (stderr,"%s:%d  ",__FILE__,__LINE__);fprintf (stderr,p, ## args) */
+#define BGEXI_ERROR_BGEXID(id) error ("Illegal bgexid \"%d\".", id)
+
+enum
+{
+  BGEXI_OBJECT_LENGTH = 16,
+  BGEXID_BUFFER_LENGTH = 4 * BGEXI_OBJECT_LENGTH,
+  BGEXI_FILENAME_LENGTH = 1024,
+  BGEXI_DISPLAY_NAME_LENGTH = 1024,
+  BGEXI_IDENTIFIER_LENGTH = 1024,
+
+  BGEXI_DYNAMIC_COLOR_DEFAULT = 65536 / 2
+};
+enum
+{
+  BGEXI_IMAGE_TYPE_XPM,
+  BGEXI_IMAGE_TYPE_PNG,
+  BGEXI_IMAGE_TYPE_JPEG,
+
+  BGEXI_IMAGE_TYPE_ERROR
+};
+enum
+{
+  BGEXID_IDENTIFIER_TYPE_ERROR,
+
+  BGEXID_IDENTIFIER_TYPE_DEFAULT,
+  BGEXID_IDENTIFIER_TYPE_MAJOR_MODE,
+  BGEXID_IDENTIFIER_TYPE_MAJOR_MODE_REGEXP,
+  BGEXID_IDENTIFIER_TYPE_BUFFER_NAME,
+  BGEXID_IDENTIFIER_TYPE_BUFFER_NAME_REGEXP
+};
+
+struct bgexi_object
+{
+  int create_p;
+  int failed_p;
+
+  int trigger_create_p;
+  int trigger_destroy_p;
+  int trigger_restart_p;
+
+  int enable_p;
+  int dynamic_color_p;
+  int dynamic_color_factor;
+  int fill_pixmap_p;
+  int r,g,b;
+
+  int created_length;
+
+  unsigned long current_tick_tick;
+  unsigned long current_tick;
+
+  GC fixed_gc;
+  char filename[BGEXI_FILENAME_LENGTH];
+
+  int create_image_p;
+  int width;
+  int height;
+  XImage *image;
+  XImage *work_image;
+  Pixmap pixmap;
+  int rgba[4];
+};
+
+struct bgexid_unit
+{
+  int create_p;
+  int trigger_destroy_p;
+  int bgexid;
+  char identifier[BGEXI_IDENTIFIER_LENGTH];
+  int identifier_type;
+  struct bgexid_unit *next;
+};
+
+struct object_parameter
+{
+  int dynamic_color_p;
+  int fill_pixmap_p;
+  int r,g,b;
+  char filename[BGEXI_FILENAME_LENGTH];
+  int xpm_string_allocate_size;
+  char *xpm_string;
+};
+
+static struct
+{
+  int disable_p;
+  int trigger_enable_p;
+  int trigger_disable_p;
+
+  int default_p;
+  int default_bgexid;
+
+  struct bgexid_unit id_buffer[BGEXID_BUFFER_LENGTH];
+  struct bgexid_unit *id_list_table[BGEXI_OBJECT_LENGTH];
+  struct bgexi_object object[BGEXI_OBJECT_LENGTH];
+  char display_name[BGEXI_DISPLAY_NAME_LENGTH];
+
+  int force_slow_background_pixmap_p;
+  int fast_background_pixmap_p;
+  int special_trigger_p;
+
+  int overstrike_p;
+
+  int object_parameter_fast_background_pixmap_p;
+  struct object_parameter object_parameter[BGEXI_OBJECT_LENGTH];
+} bgexi_work;
+
+/*
+  BGEX prototype
+ */
+static int
+bgexi_get_mask_length (Visual *visual, u_long mask);
+static u_long
+bgexi_get_left_shift_times (Visual *visual, u_long mask);
+static void
+bgexi_image_convert_bpp32 (XImage *src_image,
+                           XImage *dst_image,
+                           int *rgba,
+                           int factor,
+                           int image_width,
+                           int image_height,
+                           int src_x,
+                           int src_y,
+                           int width,
+                           int height,
+                           int order);
+static void
+bgexi_image_convert_bpp16 (XImage *src_image,
+                           XImage *dst_image,
+                           int *rgba,
+                           int factor,
+                           int image_width,
+                           int image_height,
+                           int src_x,
+                           int src_y,
+                           int width,
+                           int height,
+                           int order,
+                           XVisualInfo *vinfo);
+static void
+bgexi_image_convert (struct frame *f,
+                     XImage *src_image,
+                     XImage *dst_image,
+                     int *rgba,
+                     int factor,
+                     int image_width,
+                     int image_height,
+                     int src_x,
+                     int src_y,
+                     int width,
+                     int height);
+static int
+bgexi_check_image_type_by_extension (char *filename);
+#if HAVE_XPM
+static void
+bgexi_create_image_xpm (struct bgexi_object *object,
+                        struct frame *f,
+                        struct object_parameter *object_parameter);
+#endif  /* HAVE_XPM */
+#if HAVE_PNG
+static int
+bgexi_png_read_file_to_image (struct frame *f,
+                              char *filename,
+                              XImage **image,
+                              int *width,
+                              int *height);
+static void
+bgexi_create_image_png (struct bgexi_object *object,
+                        struct frame *f);
+#endif  /* HAVE_PNG */
+#if HAVE_JPEG
+static int
+bgexi_jpeg_read_file_to_image (struct frame *f,
+                               char *filename,
+                               XImage **image,
+                               int *width,
+                               int *height);
+static void
+bgexi_create_image_jpeg (struct bgexi_object *object,
+                         struct frame *f);
+#endif  /* HAVE_JPEG */
+static void
+bgexi_create_image (struct bgexi_object *object,
+                    struct frame *f,
+                    struct object_parameter *object_parameter);
+static void
+bgexi_create (int bgexid,
+              struct frame *f,
+              int dynamic_color_factor);
+static void
+bgexi_destroy (int bgexid,
+               struct frame *f);
+static int
+bgexi_intersect_rectangles (XRectangle *r1, XRectangle *r2,
+                            XRectangle *result);
+static int
+bgexi_check_bgexid (int bgexid);
+static void
+bgexi_set_active_flag (int bgexid, int flag);
+static int
+bgexi_get_active_flag (int bgexid);
+static void
+bgexi_set_dynamic_color_flag (int bgexid, int flag);
+int
+bgexi_get_dynamic_color_flag (int bgexid);
+static void
+bgexi_set_dynamic_color_factor (int bgexid, int factor);
+static int
+bgexi_get_dynamic_color_factor (int bgexid);
+static void
+bgexi_set_color (int bgexid, int r, int g, int b);
+static void
+bgexi_clear_image_filename_parameter (int bgexid);
+static void
+bgexi_set_disable_flag (int flag);
+static void
+bgexi_set_force_slow_background_pixmap_flag (int flag);
+static void
+bgexi_set_trigger_create (int bgexid);
+static void
+bgexi_set_parameter (int bgexid,
+                     int fast_background_pixmap_p,
+                     int dynamic_color_p,
+                     int fill_pixmap_p,
+                     int r,
+                     int g,
+                     int b,
+                     char *filename);
+static void
+bgexi_set_parameter_for_xpm_string (int bgexid,
+                                    int fast_background_pixmap_p,
+                                    int dynamic_color_p,
+                                    int fill_pixmap_p,
+                                    int r,
+                                    int g,
+                                    int b,
+                                    char *xpm_string);
+static void
+bgexi_set_trigger_destroy (int bgexid);
+static void
+bgexi_set_trigger_restart (int bgexid);
+static int
+bgexid_check_identifier_type_default (void);
+static int
+bgexid_check_identifier_type (char *identifier, int identifier_type);
+static int
+bgexid_create (char *identifier, int type);
+static int
+bgexid_destroy (int bgexid);
+static int
+bgexid_add (int bgexid, char *identifier, int type);
+static int
+bgexid_delete (int bgexid, char *identifier, int type);
+static int
+bgexid_get_identifier_type (char *symbol_cstring);
+static int
+bgexi_fill_color (GC gc, struct window *window,
+                  int x, int y, int w, int h, int *rgba,
+                  int bgexid);
+
+/*
+ */
+int
+bgexi_p (int bgexid);
+int
+bgexi_fast_p (void);
+int
+bgexi_only_fast_p (void);
+void
+bgexi_redraw_all (void);
+int
+bgexi_get_enable_bgexid (struct window *window);
+int
+bgexi_special_trigger_p (struct window *window);
+int
+bgexi_clear_special_trigger_p (void);
+int
+bgexi_fill_rectangle (GC gc, struct window *window,
+                      int x, int y, int w, int h, int *rgba);
+void
+bgexi_set_overstrike_flag (int overstrike_p);
+int
+bgexi_overstrike_p (void);
+
+/*
+
+BGEX
+
+FACTOR
+
+R = Rpixmap * Rcolor / factor
+G = Gpixmap * Gcolor / factor
+B = Bpixmap * Bcolor / factor
+
+	`factor = 65536' means 1.0.
+	default `factor = 3 * 65536 / 4'
+
+ */
+
+static int
+bgexi_get_mask_length (Visual *visual, u_long mask)
+{
+  int length = 0;
+  u_long c = 0x00000001L;
+
+  switch (visual->class)
+    {
+    case TrueColor:
+      while (1)
+        {
+          if (mask & c)
+            break;
+          c <<= 1;
+        }
+      while (length < 32)
+        {
+          if (((mask & c) == 0) || c == 0x80000000L)
+            break;
+          length++;
+          c <<= 1;
+        }
+      return length;
+
+    default:
+      break;
+    }
+
+  return 0;
+}
+
+static u_long
+bgexi_get_left_shift_times (Visual *visual, u_long mask)
+{
+  u_long shift = 0;
+  u_long c = 0x00000001L;
+
+  switch (visual->class)
+    {
+    case TrueColor:
+      while (shift < 24)
+        {
+          if (mask & c)
+            return shift;
+          c <<= 1;
+          shift++;
+        }
+      break;
+
+    default:
+      break;
+    }
+
+  return 0;
+}
+
+static void
+bgexi_image_convert_bpp32 (XImage *src_image, XImage *dst_image, int *rgba, int factor, int image_width, int image_height, int src_x, int src_y, int width, int height, int order)
+{
+  int x,y;
+  int r = rgba[0];
+  int g = rgba[1];
+  int b = rgba[2];
+
+  switch (order)
+    {
+    case LSBFirst:
+      for (y = 0;y != height;y++)
+        {
+          if ((y >= 0) &&
+              (y < image_height) &&
+              (y + src_y >= 0) &&
+              (y + src_y < image_height))
+            {
+              for (x = 0;x != width;x++)
+                {
+                  if ((x >= 0) &&
+                      (x < image_width) &&
+                      (x + src_x >= 0) &&
+                      (x + src_x < image_width))
+                    {
+                      int t;
+                      unsigned long src;
+                      unsigned long dst;
+                      src = *((unsigned long*)(src_image->data + (src_x + x)*4 + (src_y + y)*src_image->bytes_per_line));
+
+                      t = ((src >> 0) & 0xff) * b / factor;
+                      dst  = ((t > 255) ? 255 : t) << 0;
+                      t = ((src >> 8) & 0xff) * g / factor;
+                      dst |= ((t > 255) ? 255 : t) << 8;
+                      t = ((src >> 16) & 0xff) * r / factor;
+                      dst |= ((t > 255) ? 255 : t) << 16;
+
+                      *((unsigned long*)(dst_image->data + x*4 + y*dst_image->bytes_per_line)) = dst;
+                    }
+                }
+            }
+        }
+      break;
+    case MSBFirst:
+      for (y = 0;y != height;y++)
+        {
+          if ((y >= 0) &&
+              (y < image_height) &&
+              (y + src_y >= 0) &&
+              (y + src_y < image_height))
+            {
+              for (x = 0;x != width;x++)
+                {
+                  if ((x >= 0) &&
+                      (x < image_width) &&
+                      (x + src_x >= 0) &&
+                      (x + src_x < image_width))
+                    {
+                      int t;
+                      unsigned long src;
+                      unsigned long dst;
+                      src = *((unsigned long*)(src_image->data + (src_x + x)*4 + (src_y + y)*src_image->bytes_per_line));
+
+                      t = ((src >> 0) & 0xff) * b / factor;
+                      dst  = ((t > 255) ? 255 : t) << 8;
+                      t = ((src >> 8) & 0xff) * g / factor;
+                      dst |= ((t > 255) ? 255 : t) << 16;
+                      t = ((src >> 16) & 0xff) * r / factor;
+                      dst |= ((t > 255) ? 255 : t) << 24;
+
+                      *((unsigned long*)(dst_image->data + x*4 + y*dst_image->bytes_per_line)) = dst;
+                    }
+                }
+            }
+        }
+      break;
+    }
+}
+
+static void
+bgexi_image_convert_bpp16 (XImage *src_image, XImage *dst_image, int *rgba, int factor, int image_width, int image_height, int src_x, int src_y, int width, int height, int order, XVisualInfo *vinfo)
+{
+  int x,y;
+  int r = rgba[0];
+  int g = rgba[1];
+  int b = rgba[2];
+  int rmask = vinfo->red_mask;
+  int gmask = vinfo->green_mask;
+  int bmask = vinfo->blue_mask;
+  int rshift = bgexi_get_left_shift_times (vinfo->visual, rmask);
+  int gshift = bgexi_get_left_shift_times (vinfo->visual, gmask);
+  int bshift = bgexi_get_left_shift_times (vinfo->visual, bmask);
+  int rmax = (1 << bgexi_get_mask_length (vinfo->visual, rmask)) - 1;
+  int gmax = (1 << bgexi_get_mask_length (vinfo->visual, gmask)) - 1;
+  int bmax = (1 << bgexi_get_mask_length (vinfo->visual, bmask)) - 1;
+
+  switch (order)
+    {
+    case LSBFirst:
+      for (y = 0;y != height;y++)
+        {
+          if ((y >= 0) &&
+              (y < image_height) &&
+              (y + src_y >= 0) &&
+              (y + src_y < image_height))
+            {
+              for (x = 0;x != width;x++)
+                {
+                  if ((x >= 0) &&
+                      (x < image_width) &&
+                      (x + src_x >= 0) &&
+                      (x + src_x < image_width))
+                    {
+                      int t;
+                      unsigned short src;
+                      unsigned short dst;
+                      src = *((unsigned short*)(src_image->data + (src_x + x)*2 + (src_y + y)*src_image->bytes_per_line));
+
+                      t = ((src & bmask) >> bshift) * b / factor;
+                      dst  = (((t & bmask) > bmax) ? bmax : t) << bshift;
+                      t = ((src & gmask) >> gshift) * g / factor;
+                      dst |= (((t & gmask) > gmax) ? gmax : t) << gshift;
+                      t = ((src & rmask) >> rshift) * r / factor;
+                      dst |= (((t & rmask) > rmax) ? rmax : t) << rshift;
+
+                      *((unsigned short*)(dst_image->data + x*2 + y*dst_image->bytes_per_line)) = dst;
+                    }
+                }
+            }
+        }
+      break;
+    case MSBFirst:
+      for (y = 0;y != height;y++)
+        {
+          if ((y >= 0) &&
+              (y < image_height) &&
+              (y + src_y >= 0) &&
+              (y + src_y < image_height))
+            {
+              for (x = 0;x != width;x++)
+                {
+                  if ((x >= 0) &&
+                      (x < image_width) &&
+                      (x + src_x >= 0) &&
+                      (x + src_x < image_width))
+                    {
+                      int t;
+                      unsigned short src;
+                      unsigned short dst;
+                      src = *((unsigned short*)(src_image->data + (src_x + x)*2 + (src_y + y)*src_image->bytes_per_line));
+
+                      t = ((src & bmask) >> bshift) * b / factor;
+                      dst  = (((t & bmask) > bmax) ? bmax : t) << bshift;
+                      t = ((src & gmask) >> gshift) * g / factor;
+                      dst |= (((t & gmask) > gmax) ? gmax : t) << gshift;
+                      t = ((src & rmask) >> rshift) * r / factor;
+                      dst |= (((t & rmask) > rmax) ? rmax : t) << rshift;
+
+                      *((unsigned short*)(dst_image->data + x*2 + y*dst_image->bytes_per_line)) = dst;
+                    }
+                }
+            }
+        }
+      break;
+    }
+}
+
+static void
+bgexi_image_convert (struct frame *f, XImage *src_image, XImage *dst_image, int *rgba, int factor, int image_width, int image_height, int src_x, int src_y, int width, int height)
+{
+  switch (src_image->bits_per_pixel)
+    {
+    case 32:
+    case 24:
+      bgexi_image_convert_bpp32 (src_image,
+                                 dst_image,
+                                 rgba,
+                                 factor,
+                                 image_width,
+                                 image_height,
+                                 src_x,
+                                 src_y,
+                                 width,
+                                 height,
+                                 ImageByteOrder (FRAME_X_DISPLAY (f)));
+      break;
+    case 16:
+    case 15:
+      {
+        XVisualInfo vinfo;
+        XMatchVisualInfo (FRAME_X_DISPLAY (f), FRAME_X_SCREEN_NUMBER (f),
+                          DefaultDepth (FRAME_X_DISPLAY (f), FRAME_X_SCREEN_NUMBER (f)),
+                          FRAME_X_VISUAL (f)->class, &vinfo);
+        bgexi_image_convert_bpp16 (src_image,
+                                   dst_image,
+                                   rgba,
+                                   factor,
+                                   image_width,
+                                   image_height,
+                                   src_x,
+                                   src_y,
+                                   width,
+                                   height,
+                                   ImageByteOrder (FRAME_X_DISPLAY (f)),
+                                   &vinfo);
+      }
+      break;
+    }
+}
+
+static int
+bgexi_check_image_type_by_extension (char *filename)
+{
+  Lisp_Object lisp_filename = build_string (filename);
+  int result;
+
+  if (!NILP (Fstring_match (make_pure_string ("\\.xpm$", 6, 6, 0), lisp_filename, Qnil)))
+    {
+      result = BGEXI_IMAGE_TYPE_XPM;
+    }
+  else if (!NILP (Fstring_match (make_pure_string ("\\.png$", 6, 6, 0), lisp_filename, Qnil)))
+    {
+      result = BGEXI_IMAGE_TYPE_PNG;
+    }
+  else if (!NILP (Fstring_match (make_pure_string ("\\.jpe?g$", 8, 8, 0), lisp_filename, Qnil)))
+    {
+      result = BGEXI_IMAGE_TYPE_JPEG;
+    }
+  else
+    {
+      result = BGEXI_IMAGE_TYPE_ERROR;
+    }
+
+  return result;
+}
+
+#if HAVE_XPM
+#include "X11/xpm.h"
+static void
+bgexi_create_image_xpm (struct bgexi_object *object, struct frame *f, struct object_parameter *object_parameter)
+{
+  XpmAttributes attrs;
+
+  object->create_image_p = 1;
+
+  memset (&attrs, 0, sizeof (attrs));
+  attrs.visual = FRAME_X_VISUAL (f);
+  attrs.colormap = FRAME_X_COLORMAP (f);
+  attrs.valuemask |= XpmVisual;
+  attrs.valuemask |= XpmColormap;
+
+  int xpm_result;
+  BGEXI_DBP ("try bgexi_create_image_xpm (). object_parameter=%p\n", object_parameter);
+  if (object_parameter && (object_parameter->xpm_string_allocate_size > 0))
+    {
+      BGEXI_DBP ("try XpmCreateImageFromBuffer ()\n");
+      xpm_result = XpmCreateImageFromBuffer (FRAME_X_DISPLAY (f),
+                                             object_parameter->xpm_string,
+                                             &object->image,
+                                             0,
+                                             &attrs);
+      BGEXI_DBP ("xpm_result=%d\n", xpm_result);
+      BGEXI_DBP ("xpm_string=%s\n", object_parameter->xpm_string);
+    }
+  else
+    {
+      BGEXI_DBP ("try XpmReadFileToImage ()\n");
+      xpm_result = XpmReadFileToImage (FRAME_X_DISPLAY (f),
+                                       object->filename,
+                                       &object->image,
+                                       0,
+                                       &attrs);
+      BGEXI_DBP ("try XpmReadFileToImage (). xpm:\"%s\"\n", object->filename);
+    }
+  if (xpm_result != XpmSuccess)
+    {
+      BGEXI_DBP ("XpmReadFileToImage () failed.  set failed_p\n");
+      object->failed_p = 1;
+    }
+  else
+    {
+      object->width = attrs.width;
+      object->height = attrs.height;
+
+      object->work_image = XCreateImage (FRAME_X_DISPLAY (f),
+                                         DefaultVisualOfScreen (FRAME_X_SCREEN (f)),
+                                         DefaultDepth (FRAME_X_DISPLAY (f), FRAME_X_SCREEN_NUMBER (f)),
+                                         ZPixmap,
+                                         0,
+                                         NULL,
+                                         object->width,
+                                         object->height,
+                                         32,
+                                         0);
+      object->work_image->data = (char *) xmalloc (object->work_image->bytes_per_line * object->height);
+      object->pixmap = XCreatePixmap (FRAME_X_DISPLAY (f), FRAME_X_DRAWABLE (f),
+                                      object->width, object->height,
+                                      DefaultDepth (FRAME_X_DISPLAY (f), FRAME_X_SCREEN_NUMBER (f)));
+
+      object->fixed_gc = XCreateGC (FRAME_X_DISPLAY (f), object->pixmap, 0, 0);
+      XPutImage (FRAME_X_DISPLAY (f), object->pixmap, object->fixed_gc, object->image,
+                 0, 0, 0, 0,
+                 object->width, object->height);
+      XpmFreeAttributes (&attrs);
+    }
+}
+#endif	/* HAVE_XPM */
+
+#if HAVE_PNG
+/*
+ */
+static int
+bgexi_png_read_file_to_image (struct frame *f, char *filename, XImage **image, int *width, int *height)
+{
+  png_structp png_ptr;
+  png_infop info_ptr;
+  unsigned int sig_read = 0;
+  FILE *fp;
+  int depth;
+
+  if ((fp = fopen (filename, "rb")) == NULL)
+    return !0;
+
+  png_ptr = png_create_read_struct (PNG_LIBPNG_VER_STRING,
+                                    0, 0, 0);
+
+  if (png_ptr == NULL)
+    {
+      fclose (fp);
+      return !0;
+    }
+
+  info_ptr = png_create_info_struct (png_ptr);
+  if (info_ptr == NULL)
+    {
+      fclose (fp);
+      png_destroy_read_struct (&png_ptr, 0, 0);
+      return !0;
+    }
+
+  if (setjmp (png_jmpbuf (png_ptr)))
+    {
+      png_destroy_read_struct (&png_ptr, &info_ptr, 0);
+      fclose (fp);
+      return !0;
+    }
+
+  png_init_io (png_ptr, fp);
+
+  png_set_sig_bytes (png_ptr, sig_read);
+
+  png_read_png (png_ptr, info_ptr,
+                PNG_TRANSFORM_STRIP_16 |
+                PNG_TRANSFORM_STRIP_ALPHA |
+                PNG_TRANSFORM_EXPAND,
+                0);
+
+  *width = png_get_image_width (png_ptr, info_ptr);
+  *height = png_get_image_height (png_ptr, info_ptr);
+  depth = DefaultDepth (FRAME_X_DISPLAY (f), FRAME_X_SCREEN_NUMBER (f));
+  *image = XCreateImage (FRAME_X_DISPLAY (f),
+                        DefaultVisualOfScreen (FRAME_X_SCREEN (f)),
+			depth, ZPixmap, 0, NULL,
+                        *width, *height,
+			depth > 16 ? 32 : depth > 8 ? 16 : 8, 0);
+  (*image)->data = (char *) xmalloc ((*image)->bytes_per_line * *height);
+  {
+    int x;
+    int y;
+
+    png_bytepp rows = png_get_rows (png_ptr, info_ptr);
+    for (y = 0; y < *height; ++y)
+      {
+        for (x = 0; x < *width; ++x)
+          {
+            unsigned long pixel;
+            pixel  = *(*(rows + y) + 0 + x*3) << (2 * 8);
+            pixel |= *(*(rows + y) + 1 + x*3) << (1 * 8);
+            pixel |= *(*(rows + y) + 2 + x*3) << (0 * 8);
+            XPutPixel (*image, x, y, pixel);
+          }
+      }
+  }
+
+  png_destroy_read_struct (&png_ptr, &info_ptr, 0);
+
+  fclose (fp);
+
+  return 0;
+}
+
+static void
+bgexi_create_image_png (struct bgexi_object *object, struct frame *f)
+{
+  int width;
+  int height;
+
+  object->create_image_p = 1;
+
+  BGEXI_DBP ("try bgexi_png_read_file_to_image (). file:\"%s\"\n", object->filename);
+  if (bgexi_png_read_file_to_image (f, object->filename,
+                                    &object->image,
+                                    &width, &height))
+    {
+      BGEXI_DBP ("bgexi_png_read_file_to_image () failed.  set failed_p\n");
+      object->failed_p = 1;
+    }
+  else
+    {
+      object->width = width;
+      object->height = height;
+
+      object->work_image = XCreateImage (FRAME_X_DISPLAY (f),
+                                         DefaultVisualOfScreen (FRAME_X_SCREEN (f)),
+                                         DefaultDepth (FRAME_X_DISPLAY (f), FRAME_X_SCREEN_NUMBER (f)),
+                                         ZPixmap,
+                                         0,
+                                         NULL,
+                                         object->width,
+                                         object->height,
+                                         32,
+                                         0);
+      object->work_image->data = (char *) xmalloc (object->work_image->bytes_per_line * object->height);
+      object->pixmap = XCreatePixmap (FRAME_X_DISPLAY (f), FRAME_X_DRAWABLE (f),
+                                      object->width, object->height,
+                                      DefaultDepth (FRAME_X_DISPLAY (f), FRAME_X_SCREEN_NUMBER (f)));
+
+      object->fixed_gc = XCreateGC (FRAME_X_DISPLAY (f), object->pixmap, 0, 0);
+      XPutImage (FRAME_X_DISPLAY (f), object->pixmap, object->fixed_gc, object->image,
+                 0, 0, 0, 0,
+                 object->width, object->height);
+    }
+}
+#endif	/* HAVE_PNG */
+
+#if HAVE_JPEG
+#include <jpeglib.h>
+#include <jerror.h>
+#include <setjmp.h>
+/*
+ */
+struct bgexi_my_error_mgr {
+  struct jpeg_error_mgr pub;	/* "public" fields */
+
+  jmp_buf setjmp_buffer;	/* for return to caller */
+};
+
+typedef struct bgexi_my_error_mgr * bgexi_my_error_ptr;
+
+static void
+bgexi_my_error_exit (j_common_ptr cinfo)
+{
+  /* cinfo->err really points to a my_error_mgr struct, so coerce pointer */
+  bgexi_my_error_ptr myerr = (bgexi_my_error_ptr) cinfo->err;
+
+  /* Always display the message. */
+  /* We could postpone this until after returning, if we chose. */
+  (*cinfo->err->output_message) (cinfo);
+
+  /* Return control to the setjmp point */
+  longjmp (myerr->setjmp_buffer, 1);
+}
+
+static int
+bgexi_jpeg_read_file_to_image (struct frame *f, char *filename, XImage **image, int *width, int *height)
+{
+  struct jpeg_decompress_struct cinfo;
+  struct bgexi_my_error_mgr jerr;
+  FILE *fp;
+  JSAMPARRAY buffer;
+  int row_stride;
+  int depth;
+
+  fp = fopen (filename, "rb");
+  if (fp == 0)
+    return !0;
+
+  cinfo.err = jpeg_std_error (&jerr.pub);
+  jerr.pub.error_exit = bgexi_my_error_exit;
+
+  jpeg_create_decompress (&cinfo);
+  jpeg_stdio_src (&cinfo, (FILE *) fp);
+
+  jpeg_read_header (&cinfo, TRUE);
+  jpeg_start_decompress (&cinfo);
+
+  row_stride = cinfo.output_width * cinfo.output_components;
+  buffer = (*cinfo.mem->alloc_sarray)((j_common_ptr) &cinfo, JPOOL_IMAGE, row_stride, 1);
+
+  *width = cinfo.output_width;
+  *height = cinfo.output_height;
+
+  depth = DefaultDepth (FRAME_X_DISPLAY (f), FRAME_X_SCREEN_NUMBER (f));
+  *image = XCreateImage (FRAME_X_DISPLAY (f),
+                        DefaultVisualOfScreen (FRAME_X_SCREEN (f)),
+			depth, ZPixmap, 0, NULL,
+                        *width, *height,
+			depth > 16 ? 32 : depth > 8 ? 16 : 8, 0);
+  (*image)->data = (char *) xmalloc ((*image)->bytes_per_line * *height);
+  {
+    int x;
+    int y;
+    y = 0;
+
+    for (y = 0; y < *height; ++y)
+      {
+        jpeg_read_scanlines (&cinfo, buffer, 1);
+        for (x = 0; x < *width; ++x)
+          {
+            unsigned long pixel;
+            pixel = *((*buffer) + 0 + x*3) << 16;
+            pixel |= *((*buffer) + 1 + x*3) << 8;
+            pixel |= *((*buffer) + 2 + x*3) << 0;
+            XPutPixel (*image, x, y, pixel);
+          }
+      }
+  }
+
+  jpeg_finish_decompress (&cinfo);
+  jpeg_destroy_decompress (&cinfo);
+  fclose (fp);
+
+  return 0;
+}
+
+static void
+bgexi_create_image_jpeg (struct bgexi_object *object, struct frame *f)
+{
+  int width;
+  int height;
+
+  object->create_image_p = 1;
+
+  BGEXI_DBP ("try bgexi_jpeg_read_file_to_image (). file:\"%s\"\n", object->filename);
+  if (bgexi_jpeg_read_file_to_image (f, object->filename,
+                                     &object->image,
+                                     &width, &height))
+    {
+      BGEXI_DBP ("bgexi_jpeg_read_file_to_image () failed.  set failed_p\n");
+      object->failed_p = 1;
+    }
+  else
+    {
+      object->width = width;
+      object->height = height;
+
+      object->work_image = XCreateImage (FRAME_X_DISPLAY (f),
+                                         DefaultVisualOfScreen (FRAME_X_SCREEN (f)),
+                                         DefaultDepth (FRAME_X_DISPLAY (f), FRAME_X_SCREEN_NUMBER (f)),
+                                         ZPixmap,
+                                         0,
+                                         NULL,
+                                         object->width,
+                                         object->height,
+                                         32,
+                                         0);
+      object->work_image->data = (char *) xmalloc (object->work_image->bytes_per_line * object->height);
+      object->pixmap = XCreatePixmap (FRAME_X_DISPLAY (f), FRAME_X_DRAWABLE (f),
+                                      object->width, object->height,
+                                      DefaultDepth (FRAME_X_DISPLAY (f), FRAME_X_SCREEN_NUMBER (f)));
+
+      object->fixed_gc = XCreateGC (FRAME_X_DISPLAY (f), object->pixmap, 0, 0);
+      XPutImage (FRAME_X_DISPLAY (f), object->pixmap, object->fixed_gc, object->image,
+                 0, 0, 0, 0,
+                 object->width, object->height);
+    }
+}
+#endif	/* HAVE_JPEG */
+
+static void
+bgexi_create_image (struct bgexi_object *object, struct frame *f, struct object_parameter *object_parameter)
+{
+  BGEXI_DBP ("bgexi_create_image ()\n");
+  if (object->fill_pixmap_p &&
+      !object->create_image_p)
+    {
+      if (object_parameter->xpm_string_allocate_size > 0)
+        {
+#if HAVE_XPM
+          bgexi_create_image_xpm (object, f, object_parameter);
+#endif
+        }
+      else
+        {
+          switch (bgexi_check_image_type_by_extension (object->filename))
+            {
+#if HAVE_XPM
+            case BGEXI_IMAGE_TYPE_XPM:
+              bgexi_create_image_xpm (object, f, 0);
+              break;
+#endif
+#if HAVE_PNG
+            case BGEXI_IMAGE_TYPE_PNG:
+              bgexi_create_image_png (object, f);
+              break;
+#endif
+#if HAVE_JPEG
+            case BGEXI_IMAGE_TYPE_JPEG:
+              bgexi_create_image_jpeg (object, f);
+              break;
+#endif
+            default:
+              object->failed_p = 1;
+              break;
+            }
+        }
+    }
+  else
+    {
+      BGEXI_DBP ("    CREATE ALREADY! or !fill_pixmap_p\n");
+    }
+}
+
+static void
+bgexi_create (int bgexid, struct frame *f, int dynamic_color_factor)
+{
+  if (!bgexi_work.object[bgexid].create_p)
+    {
+      bgexi_work.object[bgexid].create_p = 1;
+
+      {
+        Visual *visual = DefaultVisual (FRAME_X_DISPLAY (f), FRAME_X_SCREEN_NUMBER (f));
+        switch (visual->class)
+          {
+          case TrueColor:
+          case DirectColor:
+            break;
+
+          default:
+            BGEXI_DBP ("unknown visual class.  set failed_p\n");
+            bgexi_work.object[bgexid].failed_p = 1;
+            break;
+          }
+      }
+
+      if (bgexi_work.display_name[0] == '\0')
+        {
+          if (strlen (DisplayString (FRAME_X_DISPLAY (f))) < sizeof (bgexi_work.display_name) - 1)
+            {
+              strcpy (bgexi_work.display_name, DisplayString (FRAME_X_DISPLAY (f)));
+              BGEXI_DBP ("COPY 1ST  DisplayString (dpy):\"%s\"  first:\"%s\"",
+                         DisplayString (FRAME_X_DISPLAY (f)), bgexi_work.display_name);
+            }
+          else
+            {
+              BGEXI_DBP ("string length too large.  set failed_p\n");
+              bgexi_work.object[bgexid].failed_p = 1;
+            }
+        }
+
+      bgexi_work.object[bgexid].enable_p = 1;
+
+      if (bgexi_work.object[bgexid].failed_p == 0)
+        {
+          bgexi_work.object[bgexid].dynamic_color_p = bgexi_work.object_parameter[bgexid].dynamic_color_p;
+          bgexi_work.object[bgexid].fill_pixmap_p = bgexi_work.object_parameter[bgexid].fill_pixmap_p;
+          bgexi_work.object[bgexid].r = bgexi_work.object_parameter[bgexid].r;
+          bgexi_work.object[bgexid].g = bgexi_work.object_parameter[bgexid].g;
+          bgexi_work.object[bgexid].b = bgexi_work.object_parameter[bgexid].b;
+
+          if (bgexi_work.object_parameter[bgexid].filename[0] != '\0')
+            {
+              strcpy (bgexi_work.object[bgexid].filename, bgexi_work.object_parameter[bgexid].filename);
+              BGEXI_DBP ("copy filename:%s\n", bgexi_work.object[bgexid].filename);
+            }
+
+          if (dynamic_color_factor <= 0)
+            dynamic_color_factor = 3 * 65536 / 4;
+          if (dynamic_color_factor > 65536)
+            dynamic_color_factor = 65536;
+
+          bgexi_work.object[bgexid].dynamic_color_factor = dynamic_color_factor;
+
+          if (bgexid == 0)
+            {
+              bgexi_work.fast_background_pixmap_p = bgexi_work.object_parameter_fast_background_pixmap_p;
+            }
+        }
+    }
+}
+
+static void
+bgexi_destroy (int bgexid, struct frame *f)
+{
+  BGEXI_DBP ("bgexi_destroy ()\n");
+  if (bgexi_work.object[bgexid].fill_pixmap_p &&
+      bgexi_work.object[bgexid].create_p && !bgexi_work.object[bgexid].failed_p)
+    {
+      if (bgexi_work.object[bgexid].create_image_p)
+        {
+          bgexi_work.object[bgexid].create_image_p = 0;
+          XFreePixmap (FRAME_X_DISPLAY (f), bgexi_work.object[bgexid].pixmap);
+          xfree (bgexi_work.object[bgexid].image->data);
+          bgexi_work.object[bgexid].image->data = 0;
+          XDestroyImage (bgexi_work.object[bgexid].image);
+          xfree (bgexi_work.object[bgexid].work_image->data);
+          bgexi_work.object[bgexid].work_image->data = 0;
+          XDestroyImage (bgexi_work.object[bgexid].work_image);
+        }
+      XFreeGC (FRAME_X_DISPLAY (f), bgexi_work.object[bgexid].fixed_gc);
+      BGEXI_DBP ("    try bgexi_destroy  bgexid:%2d  fill_p:%d  fast_p:%d\n",
+                 bgexid,
+                 bgexi_work.object[bgexid].fill_pixmap_p,
+                 bgexi_work.fast_background_pixmap_p);
+      if ((bgexid == 0) &&
+          bgexi_work.object[bgexid].fill_pixmap_p &&
+          bgexi_work.fast_background_pixmap_p)
+        {
+          BGEXI_DBP ("    try destroy fast BG\n");
+          XSetWindowBackgroundPixmap (FRAME_X_DISPLAY (f), FRAME_X_WINDOW (f), None);
+          XSetWindowBackground (FRAME_X_DISPLAY (f), FRAME_X_WINDOW (f), FRAME_BACKGROUND_PIXEL (f));
+          f->bgexi_background_pixmap_initialized_p = 0;
+          f->bgexi_background_pixmap_p = 0;
+          bgexi_work.fast_background_pixmap_p = 0;
+        }
+    }
+
+  BGEXI_DBP ("    DB:pip:%d  pp:%d  fp:%d\n",
+             f->bgexi_background_pixmap_initialized_p,
+             f->bgexi_background_pixmap_p,
+             bgexi_work.fast_background_pixmap_p);
+
+  memset (&bgexi_work.object[bgexid], 0, sizeof (bgexi_work.object[0]));
+}
+
+/* Determine the intersection of two rectangles R1 and R2.  Return
+   the intersection in *RESULT.  Value is non-zero if RESULT is not
+   empty.  */
+static int
+bgexi_intersect_rectangles (XRectangle *r1, XRectangle *r2, XRectangle *result)
+{
+  XRectangle *left, *right;
+  XRectangle *upper, *lower;
+  int intersection_p = 0;
+
+  /* Rearrange so that R1 is the left-most rectangle.  */
+  if (r1->x < r2->x)
+    left = r1, right = r2;
+  else
+    left = r2, right = r1;
+
+  /* X0 of the intersection is right.x0, if this is inside R1,
+     otherwise there is no intersection.  */
+  if (right->x <= left->x + left->width)
+    {
+      result->x = right->x;
+
+      /* The right end of the intersection is the minimum of the
+         the right ends of left and right.  */
+      result->width = (min (left->x + left->width, right->x + right->width)
+                       - result->x);
+
+      /* Same game for Y.  */
+      if (r1->y < r2->y)
+        upper = r1, lower = r2;
+      else
+        upper = r2, lower = r1;
+
+      /* The upper end of the intersection is lower.y0, if this is inside
+         of upper.  Otherwise, there is no intersection.  */
+      if (lower->y <= upper->y + upper->height)
+        {
+          result->y = lower->y;
+
+          /* The lower end of the intersection is the minimum of the lower
+             ends of upper and lower.  */
+          result->height = (min (lower->y + lower->height, 
+                                 upper->y + upper->height)
+                            - result->y);
+          intersection_p = 1;
+        }
+    }
+
+  return intersection_p;
+}
+
+/*
+  return true if illegal bgexid.
+ */
+static int
+bgexi_check_bgexid (int bgexid)
+{
+  int result;
+
+  if ((bgexid >= 0) &&
+      (bgexid < BGEXI_OBJECT_LENGTH))
+    {
+      result = 0;
+    }
+  else
+    {
+      result = !0;
+    }
+
+  return result;
+}
+
+static void
+bgexi_set_active_flag (int bgexid, int flag)
+{
+  if (!bgexi_check_bgexid (bgexid))
+    {
+      bgexi_work.object[bgexid].enable_p = flag;
+    }
+}
+
+static int
+bgexi_get_active_flag (int bgexid)
+{
+  int result;
+  if (bgexi_check_bgexid (bgexid))
+    {
+      result = 0;
+    }
+   else
+    {
+      result = bgexi_work.object[bgexid].enable_p;
+    }
+  return result;
+}
+
+static int
+bgexi_get_render_mode (int bgexid)
+{
+  int result;
+  if (bgexi_check_bgexid (bgexid))
+    {
+      result = 0;
+    }
+   else
+    {
+      result = bgexi_work.object[bgexid].fill_pixmap_p;
+    }
+  return result;
+}
+
+static void
+bgexi_set_dynamic_color_flag (int bgexid, int flag)
+{
+  if (!bgexi_check_bgexid (bgexid))
+    {
+      bgexi_work.object[bgexid].dynamic_color_p = flag;
+    }
+}
+
+int
+bgexi_get_dynamic_color_flag (int bgexid)
+{
+  int result;
+  if (bgexi_check_bgexid (bgexid))
+    {
+      result = 0;
+    }
+   else
+    {
+      result = bgexi_work.object[bgexid].dynamic_color_p;
+    }
+  return result;
+}
+
+static void
+bgexi_set_dynamic_color_factor (int bgexid, int factor)
+{
+  if (!bgexi_check_bgexid (bgexid))
+    {
+      if (factor == 0)
+        {
+          factor = BGEXI_DYNAMIC_COLOR_DEFAULT;
+        }
+      if (factor < 1)
+        {
+          factor = 1;
+        }
+      if (factor > 65536)
+        {
+          factor = 65536;
+        }
+      bgexi_work.object[bgexid].dynamic_color_factor = factor;
+    }
+}
+
+static int
+bgexi_get_dynamic_color_factor (int bgexid)
+{
+  int result;
+  if (bgexi_check_bgexid (bgexid))
+    {
+      result = 0;
+    }
+   else
+    {
+      result = bgexi_work.object[bgexid].dynamic_color_factor;
+    }
+  return result;
+}
+
+static void
+bgexi_set_color (int bgexid, int r, int g, int b)
+{
+  if (bgexi_check_bgexid (bgexid))
+    {
+    }
+   else
+    {
+      bgexi_work.object[bgexid].r = r;
+      bgexi_work.object[bgexid].g = g;
+      bgexi_work.object[bgexid].b = b;
+    }
+}
+
+static void
+bgexi_clear_image_filename_parameter (int bgexid)
+{
+  if (bgexi_check_bgexid (bgexid))
+    {
+    }
+   else
+    {
+      bgexi_work.object_parameter[bgexid].filename[0] = '\0';
+    }
+}
+
+static void
+bgexi_set_disable_flag (int flag)
+{
+  bgexi_work.disable_p = flag;
+  if (flag)
+    {
+      bgexi_work.trigger_disable_p = 1;
+    }
+  else
+    {
+      bgexi_work.trigger_enable_p = 1;
+    }
+}
+
+static void
+bgexi_set_force_slow_background_pixmap_flag (int flag)
+{
+  bgexi_work.force_slow_background_pixmap_p = flag;
+}
+
+static void
+bgexi_set_trigger_create (int bgexid)
+{
+  if (bgexi_check_bgexid (bgexid))
+    {
+    }
+   else
+    {
+      int i;
+      int length = 0;
+      for (i = 0;i != BGEXI_OBJECT_LENGTH;i++)
+        {
+          if (bgexi_work.id_list_table[i])
+            {
+              length++;
+            }
+        }
+      if ((bgexid == 0) && (length == 1))
+        bgexi_work.special_trigger_p = 1;
+
+      bgexi_work.object[bgexid].trigger_create_p = 1;
+    }
+}
+
+static void
+bgexi_set_parameter (int bgexid, int fast_background_pixmap_p, int dynamic_color_p, int fill_pixmap_p, int r, int g, int b, char *filename)
+{
+  if (bgexi_check_bgexid (bgexid))
+    {
+    }
+   else
+    {
+      if (bgexid == 0)
+        bgexi_work.object_parameter_fast_background_pixmap_p = fast_background_pixmap_p;
+
+      bgexi_work.object_parameter[bgexid].dynamic_color_p = dynamic_color_p;
+      bgexi_work.object_parameter[bgexid].fill_pixmap_p = fill_pixmap_p;
+      bgexi_work.object_parameter[bgexid].r = r;
+      bgexi_work.object_parameter[bgexid].g = g;
+      bgexi_work.object_parameter[bgexid].b = b;
+      if (filename)
+        strcpy (bgexi_work.object_parameter[bgexid].filename, filename);
+      else
+        bgexi_work.object_parameter[bgexid].filename[0] = '\0';
+    }
+}
+
+static void
+bgexi_set_parameter_for_xpm_string (int bgexid, int fast_background_pixmap_p, int dynamic_color_p, int fill_pixmap_p, int r, int g, int b, char *xpm_string)
+{
+  BGEXI_DBP ("bgexi_set_parameter_for_xpm_string  bgexid:%d\n", bgexid);
+  if (bgexi_check_bgexid (bgexid))
+    {
+    }
+   else
+    {
+      if (bgexid == 0)
+        bgexi_work.object_parameter_fast_background_pixmap_p = fast_background_pixmap_p;
+
+      bgexi_work.object_parameter[bgexid].dynamic_color_p = dynamic_color_p;
+      bgexi_work.object_parameter[bgexid].fill_pixmap_p = fill_pixmap_p;
+      bgexi_work.object_parameter[bgexid].r = r;
+      bgexi_work.object_parameter[bgexid].g = g;
+      bgexi_work.object_parameter[bgexid].b = b;
+      /* if (filename) */
+      /*   strcpy (bgexi_work.object_parameter[bgexid].filename, filename); */
+      /* else */
+      /*   bgexi_work.object_parameter[bgexid].filename[0] = '\0'; */
+      bgexi_work.object_parameter[bgexid].filename[0] = '\0';
+      if (xpm_string)
+        {
+          const int margin = 1 + 4;
+          int string_size_with_margin = strlen(xpm_string) + margin;
+          BGEXI_DBP ("    string_size_with_margin:%d\n", string_size_with_margin);
+          if (bgexi_work.object_parameter[bgexid].xpm_string_allocate_size < string_size_with_margin)
+            {
+              xfree(bgexi_work.object_parameter[bgexid].xpm_string);
+              bgexi_work.object_parameter[bgexid].xpm_string_allocate_size = 0;
+            }
+          if (bgexi_work.object_parameter[bgexid].xpm_string_allocate_size == 0)
+            {
+              bgexi_work.object_parameter[bgexid].xpm_string_allocate_size = string_size_with_margin;
+              bgexi_work.object_parameter[bgexid].xpm_string = xmalloc(string_size_with_margin);
+            }
+          memset (bgexi_work.object_parameter[bgexid].xpm_string, 0, string_size_with_margin);
+          strcpy(bgexi_work.object_parameter[bgexid].xpm_string, xpm_string);
+        }
+    }
+}
+
+static void
+bgexi_set_trigger_destroy (int bgexid)
+{
+  if (bgexi_check_bgexid (bgexid))
+    {
+    }
+   else
+    {
+      bgexi_work.object[bgexid].trigger_destroy_p = 1;
+    }
+}
+
+static void
+bgexi_set_trigger_restart (int bgexid)
+{
+  if (bgexi_check_bgexid (bgexid))
+    {
+    }
+   else
+    {
+      bgexi_work.object[bgexid].trigger_restart_p = 1;
+    }
+}
+
+/*
+
+bgexid static module
+
+ */
+static int
+bgexid_check_identifier_type_default (void)
+{
+  int i;
+  for (i = 0;i != BGEXID_BUFFER_LENGTH;i++)
+    {
+      if (bgexi_work.id_buffer[i].create_p &&
+          (bgexi_work.id_buffer[i].identifier_type == BGEXID_IDENTIFIER_TYPE_DEFAULT))
+        {
+          return !0;
+        }
+    }
+
+  return 0;
+}
+
+static int
+bgexid_check_identifier_type (char *identifier, int identifier_type)
+{
+  int i;
+  if (identifier)
+    {
+      for (i = 0;i != BGEXID_BUFFER_LENGTH;i++)
+        {
+          if (bgexi_work.id_buffer[i].create_p &&
+              (bgexi_work.id_buffer[i].identifier_type == identifier_type) &&
+              (strcmp (bgexi_work.id_buffer[i].identifier, identifier) == 0))
+            {
+              return !0;
+            }
+        }
+    }
+  return 0;
+}
+
+static int
+bgexid_create (char *identifier, int type)
+{
+  int bgexid;
+
+  for (bgexid = 0;bgexid != BGEXI_OBJECT_LENGTH;bgexid++)
+    {
+      if (bgexi_work.id_list_table[bgexid] == 0)
+        {
+          break;
+        }
+    }
+
+  if (bgexid == BGEXI_OBJECT_LENGTH)
+    {
+      bgexid = -1;
+    }
+  else
+    {
+      int i;
+      for (i = 0;i != BGEXID_BUFFER_LENGTH;i++)
+        {
+          if (bgexi_work.id_buffer[i].create_p == 0)
+            {
+              break;
+            }
+        }
+      if (i == BGEXID_BUFFER_LENGTH)
+        {
+          bgexid = -1;
+        }
+      else
+        {
+          if ((type == BGEXID_IDENTIFIER_TYPE_DEFAULT) &&
+              bgexid_check_identifier_type_default ())
+            {
+              /* default found error */
+              bgexid = -1;
+            }
+          else if (bgexid_check_identifier_type (identifier, type))
+            {
+              /* same type found error */
+              bgexid = -1;
+            }
+          else
+            {
+              if (type == BGEXID_IDENTIFIER_TYPE_DEFAULT)
+                {
+                  if (bgexid != 0)
+                    error ("Illegal bgexid.");
+                  bgexi_work.default_p = 1;
+                  bgexi_work.default_bgexid = bgexid;
+                }
+              bgexi_work.id_buffer[i].create_p = 1;
+              if (identifier)
+                {
+                  strncpy (bgexi_work.id_buffer[i].identifier,
+                           identifier,
+                           sizeof (bgexi_work.id_buffer[0].identifier) - 1);
+                }
+              bgexi_work.id_buffer[i].identifier_type = type;
+              bgexi_work.id_list_table[bgexid] = &bgexi_work.id_buffer[i];
+            }
+        }
+    }
+
+  return bgexid;
+}
+
+static int
+bgexid_destroy (int bgexid)
+{
+  int result = !0;
+
+  if (bgexi_check_bgexid (bgexid))
+    {
+    }
+  else
+    {
+      if (bgexi_work.id_list_table[bgexid])
+        {
+          bgexi_work.id_list_table[bgexid]->trigger_destroy_p = 1;
+          result = 0;
+        }
+    }
+
+  return result;
+}
+
+static int
+bgexid_add (int bgexid, char *identifier, int type)
+{
+  int result = !0;
+
+  if (bgexi_check_bgexid (bgexid))
+    {
+    }
+  else
+    {
+      int i;
+      {
+          struct bgexid_unit *unit = bgexi_work.id_list_table[bgexid];
+          if (unit == 0)
+            goto ERROR_NOT_FOUND;
+
+          while (unit)
+            {
+              if (unit->create_p &&
+                  (unit->identifier_type == type) &&
+                  (strcmp (unit->identifier, identifier) == 0))
+                {
+                  goto ERROR_REGISTERD_ALREADY;
+                }
+              unit = unit->next;
+            }
+      }
+      for (i = 0;i != BGEXID_BUFFER_LENGTH;i++)
+        {
+          if (bgexi_work.id_buffer[i].create_p == 0)
+            {
+              break;
+            }
+        }
+      if (i == BGEXID_BUFFER_LENGTH)
+        {
+        }
+      else
+        {
+          if ((type == BGEXID_IDENTIFIER_TYPE_DEFAULT) &&
+              bgexid_check_identifier_type_default ())
+            {
+              /* default found error */
+            }
+          else if (bgexid_check_identifier_type (identifier, type))
+            {
+              /* same type found error */
+            }
+          else
+            {
+              struct bgexid_unit *unit = bgexi_work.id_list_table[bgexid];
+
+              while (unit->next)
+                {
+                  unit = unit->next;
+                }
+              if (type == BGEXID_IDENTIFIER_TYPE_DEFAULT)
+                {
+                  bgexi_work.default_p = 1;
+                  bgexi_work.default_bgexid = bgexid;
+                }
+              bgexi_work.id_buffer[i].create_p = 1;
+              strncpy (bgexi_work.id_buffer[i].identifier,
+                       identifier,
+                       sizeof (bgexi_work.id_buffer[0].identifier) - 1);
+              bgexi_work.id_buffer[i].identifier_type = type;
+              unit->next = &bgexi_work.id_buffer[i];
+              result = 0;
+            }
+        }
+    }
+
+ ERROR_NOT_FOUND:
+ ERROR_REGISTERD_ALREADY:
+  return result;
+}
+
+static int
+bgexid_delete (int bgexid, char *identifier, int type)
+{
+  int result = !0;
+
+  if (bgexi_check_bgexid (bgexid))
+    {
+    }
+  else
+    {
+      struct bgexid_unit *unit = bgexi_work.id_list_table[bgexid];
+      struct bgexid_unit *parent = 0;
+
+      while (unit)
+        {
+          if ((unit->identifier_type == type) &&
+              (strcmp (unit->identifier, identifier) == 0))
+            {
+              if (parent)
+                {
+                  parent->next = unit->next;
+                }
+              else
+                {
+                  bgexi_work.id_list_table[bgexid] = unit->next;
+                }
+              memset (unit, 0, sizeof (*unit));
+              result = 0;
+              if (type == BGEXID_IDENTIFIER_TYPE_DEFAULT)
+                {
+                  bgexi_work.default_p = 0;
+                }
+              break;
+            }
+          parent = unit;
+          unit = unit->next;
+        }
+    }
+
+  return result;
+}
+
+static int
+bgexid_get_identifier_type (char *symbol_cstring)
+{
+  int result;
+
+  if (strcmp ("bgex-identifier-type-default", symbol_cstring) == 0)
+    {
+      result = BGEXID_IDENTIFIER_TYPE_DEFAULT;
+    }
+  else if (strcmp ("bgex-identifier-type-major-mode", symbol_cstring) == 0)
+    {
+      result = BGEXID_IDENTIFIER_TYPE_MAJOR_MODE;
+    }
+  else if (strcmp ("bgex-identifier-type-major-mode-regexp", symbol_cstring) == 0)
+    {
+      result = BGEXID_IDENTIFIER_TYPE_MAJOR_MODE_REGEXP;
+    }
+  else if (strcmp ("bgex-identifier-type-buffer-name", symbol_cstring) == 0)
+    {
+      result = BGEXID_IDENTIFIER_TYPE_BUFFER_NAME;
+    }
+  else if (strcmp ("bgex-identifier-type-buffer-name-regexp", symbol_cstring) == 0)
+    {
+      result = BGEXID_IDENTIFIER_TYPE_BUFFER_NAME_REGEXP;
+    }
+  else
+    {
+      result = BGEXID_IDENTIFIER_TYPE_ERROR;
+    }
+
+  return result;
+}
+
+static int
+bgexi_fill_color (GC gc, struct window *window, int x, int y, int w, int h, int *rgba, int bgexid)
+{
+  int result = 0;
+  struct frame *f = XFRAME (WINDOW_FRAME (window));
+
+  if (window)
+    {
+      Colormap cmap = FRAME_X_COLORMAP (f);
+      XColor color;
+
+      if (rgba)
+        {
+          int factor = bgexi_work.object[bgexid].dynamic_color_factor / 3;
+          int tmp;
+          tmp = (bgexi_work.object[bgexid].r * *(rgba + 0) / 4) / factor;
+          if (tmp > 65535)
+            tmp = 65535;
+          color.red = tmp;
+          tmp = (bgexi_work.object[bgexid].g * *(rgba + 1) / 4) / factor;
+          if (tmp > 65535)
+            tmp = 65535;
+          color.green = tmp;
+          tmp = (bgexi_work.object[bgexid].b * *(rgba + 2) / 4) / factor;
+          if (tmp > 65535)
+            tmp = 65535;
+          color.blue = tmp;
+        }
+      else
+        {
+          color.red = bgexi_work.object[bgexid].r;
+          color.green = bgexi_work.object[bgexid].g;
+          color.blue = bgexi_work.object[bgexid].b;
+        }
+
+      if (XAllocColor (FRAME_X_DISPLAY (f), cmap, &color))
+        {
+	  XGCValues xgcv;
+	  XGetGCValues (FRAME_X_DISPLAY (f), gc, GCForeground, &xgcv);
+          XSetForeground (FRAME_X_DISPLAY (f), gc, color.pixel);
+          XFillRectangle (FRAME_X_DISPLAY (f), FRAME_X_DRAWABLE (f), gc,
+                          x, y, w, h);
+          XSetForeground (FRAME_X_DISPLAY (f), gc, xgcv.foreground);
+        }
+      else
+        {
+          result = !0;
+        }
+    }
+  else
+    {
+      result = !0;
+    }
+
+  return result;
+}
+
+/*
+
+bgex global module
+
+ */
+
+int
+bgexi_fast_p (void)
+{
+  int result;
+
+  if (bgexi_work.force_slow_background_pixmap_p)
+    {
+      result = 0;
+    }
+  else
+    {
+      result = bgexi_work.fast_background_pixmap_p;
+    }
+
+  return result;
+}
+
+int
+bgexi_only_fast_p (void)
+{
+  int result = 0;
+
+  if (!bgexi_work.force_slow_background_pixmap_p)
+    {
+      if (bgexi_work.fast_background_pixmap_p)
+        {
+          int i;
+          int length = 0;
+          for (i = 0;i != BGEXI_OBJECT_LENGTH;i++)
+            {
+              if (bgexi_work.object[i].create_p &&
+                  !bgexi_work.object[i].failed_p &&
+                  bgexi_work.object[i].enable_p)
+                {
+                  length++;
+                }
+            }
+
+          if (length == 1)
+            {
+              result = 1;
+            }
+        }
+    }
+
+  return result;
+}
+
+/*
+  search all bgexid if bgexid < 0
+ */
+int
+bgexi_p (int bgexid)
+{
+  int result = 0;
+
+  if (bgexi_work.disable_p &&
+      !bgexi_work.trigger_enable_p &&
+      !bgexi_work.trigger_disable_p)
+    {
+      return result;
+    }
+
+  if (bgexid < 0)
+    {
+      int i;
+      for (i = 0;i != BGEXI_OBJECT_LENGTH;i++)
+        {
+          if (bgexi_work.id_list_table[i] &&
+              bgexi_work.id_list_table[i]->create_p)
+            {
+              if (bgexi_work.object[i].create_p &&
+                  (!bgexi_work.object[i].failed_p) &&
+                  bgexi_work.object[i].enable_p)
+                {
+                  result = !0;
+                  break;
+                }
+            }
+        }
+    }
+  else
+    {
+      if (!bgexi_check_bgexid (bgexid))
+        {
+          if (bgexi_work.object[bgexid].create_p &&
+              !bgexi_work.object[bgexid].failed_p)
+            result = bgexi_work.object[bgexid].enable_p;
+        }
+    }
+
+  return result;
+}
+
+static int
+bgexi_get_bgexid (struct window *window)
+{
+  int bgexid;
+
+  if (window == 0)
+    {
+      bgexid = -1;
+    }
+  else
+    {
+      for (bgexid = 0;bgexid != BGEXI_OBJECT_LENGTH;bgexid++)
+        {
+          if (bgexi_work.id_list_table[bgexid] &&
+              bgexi_work.id_list_table[bgexid]->create_p)
+            {
+              struct bgexid_unit *unit = bgexi_work.id_list_table[bgexid];
+              Lisp_Object obj;
+              struct buffer *b = XBUFFER (window->contents);
+              if (!NILP (window->contents)) {
+                while (unit)
+                  {
+                    switch (unit->identifier_type)
+                      {
+                      case BGEXID_IDENTIFIER_TYPE_DEFAULT:
+                        break;
+
+                      case BGEXID_IDENTIFIER_TYPE_MAJOR_MODE:
+                        obj = BVAR (b, mode_name);
+                        if (STRINGP (obj))
+                          {
+                            BGEXI_DBP ("bgexid:%2d  major-mode:%s  ,  %s\n",
+                                       bgexid,
+                                       unit->identifier,
+                                       SDATA (BVAR (b, mode_name)));
+                            if (strcmp (unit->identifier, SSDATA (BVAR (b, mode_name))) == 0)
+                              {
+                                goto FOUND;
+                              }
+                          }
+                        break;
+
+                      case BGEXID_IDENTIFIER_TYPE_MAJOR_MODE_REGEXP:
+                        obj = BVAR (b, mode_name);
+                        if (STRINGP (obj))
+                          {
+                            BGEXI_DBP ("bgexid:%2d  major-mode:%s  ,  %s\n",
+                                       bgexid,
+                                       unit->identifier,
+                                       SDATA (BVAR (b, mode_name)));
+                            if (!NILP (Fstring_match (make_string (unit->identifier, strlen (unit->identifier)),
+                                                      BVAR (b, mode_name),
+                                                      Qnil)))
+                              {
+                                goto FOUND;
+                              }
+                          }
+                        break;
+
+                      case BGEXID_IDENTIFIER_TYPE_BUFFER_NAME:
+                        obj = BVAR (b, name);
+                        if (STRINGP (obj))
+                          {
+                            BGEXI_DBP ("bgexid:%2d  buffer-name:%s  ,  %s\n",
+                                       bgexid,
+                                       unit->identifier,
+                                       SDATA (BVAR (b, name)));
+                            if (strcmp (unit->identifier, SSDATA (BVAR (b, name))) == 0)
+                              {
+                                goto FOUND;
+                              }
+                          }
+                        break;
+
+                      case BGEXID_IDENTIFIER_TYPE_BUFFER_NAME_REGEXP:
+                        obj = BVAR (b, name);
+                        if (STRINGP (obj))
+                          {
+                            BGEXI_DBP ("bgexid:%2d  buffer-name:%s  ,  %s\n",
+                                       bgexid,
+                                       unit->identifier,
+                                       SDATA (BVAR (b, name)));
+                            if (!NILP (Fstring_match (make_string (unit->identifier, strlen (unit->identifier)),
+                                                      BVAR (b, name),
+                                                      Qnil)))
+                              {
+                                goto FOUND;
+                              }
+                          }
+                        break;
+
+                      default:
+                        BGEXI_DBP ("unknown identifier_type:%d\n",unit->identifier_type);
+                        break;
+                      }
+                    unit = unit->next;
+                  }
+              }
+            }
+        }
+    FOUND:
+      if (bgexid == BGEXI_OBJECT_LENGTH)
+        {
+          if (bgexi_work.default_p)
+            {
+              bgexid = bgexi_work.default_bgexid;
+            }
+          else
+            {
+              bgexid = -1;
+            }
+        }
+    }
+
+  return bgexid;
+}
+
+static void
+bgexi_redraw_window_internal (struct window *window)
+{
+  window->bgexi_redisplay_p = 1;
+}
+
+static int
+bgexi_foreach_window_1 (struct window *window)
+{
+  int cont;
+
+  for (cont = 1; window && cont;)
+    {
+      if (WINDOWP (window->contents))
+        cont = bgexi_foreach_window_1 (XWINDOW (window->contents));
+
+      window->bgexi_redisplay_p = 1;
+
+      window = NILP (window->next) ? 0 : XWINDOW (window->next);
+    }
+
+  return cont;
+}
+
+void
+bgexi_redraw_all (void)
+{
+  struct frame *f = SELECTED_FRAME ();
+  if (f && FRAME_X_P (f) && FRAME_LIVE_P (f))
+    {
+      bgexi_foreach_window_1 (XWINDOW (f->root_window));
+    }
+}
+
+int
+bgexi_get_enable_bgexid (struct window *window)
+{
+  int result = bgexi_get_bgexid (window);
+
+  if (result >= 0)
+    {
+      if (!bgexi_work.object[result].create_p ||
+          !bgexi_work.object[result].enable_p ||
+          bgexi_work.object[result].failed_p)
+        {
+          result = -1;
+        }
+    }
+
+  return result;
+}
+
+int bgexi_special_trigger_p (struct window *window)
+{
+  if (bgexid_check_identifier_type_default())
+    {
+      return bgexi_work.special_trigger_p;
+    }
+  if (bgexi_get_bgexid(window) >= 0) {
+      return bgexi_work.special_trigger_p;
+  }
+  return 0;
+}
+
+int bgexi_clear_special_trigger_p (void)
+{
+  return bgexi_work.special_trigger_p = 0;
+}
+
+int
+bgexi_fill_rectangle (GC gc, struct window *window, int x, int y, int w, int h, int *rgba)
+{
+  int result = 0;
+  int bgexid;
+  int illegal_display_p;
+  struct frame *f;
+
+
+  if (window == 0)
+    return 1;
+
+  f = XFRAME (WINDOW_FRAME(window));
+
+
+  /*
+    check special internal event
+  */
+  if (bgexi_work.trigger_disable_p)
+    {
+      bgexid = bgexi_get_bgexid (window);
+      if (bgexid < 0)
+        {
+          BGEXI_DBP ("trigger_disable_p  bgexid not found.\n");
+        }
+      else
+        {
+          if (bgexid == 0)
+            {
+              bgexi_work.trigger_disable_p = 0;
+              if (f->bgexi_background_pixmap_p &&
+                  bgexi_work.object[bgexid].fill_pixmap_p &&
+                  bgexi_work.fast_background_pixmap_p)
+                {
+                  XSetWindowBackgroundPixmap (FRAME_X_DISPLAY (f), FRAME_X_WINDOW (f), None);
+                  XSetWindowBackground (FRAME_X_DISPLAY (f), FRAME_X_WINDOW (f), FRAME_BACKGROUND_PIXEL (f));
+                  f->bgexi_background_pixmap_initialized_p = 0;
+                  f->bgexi_background_pixmap_p = 0;
+                }
+            }
+        }
+    }
+
+
+  if (bgexi_work.disable_p)
+    return 1;
+
+
+  /*
+    get illegal_display_p
+   */
+  if ((bgexi_work.display_name[0] != '\0') &&
+      (strcmp (DisplayString (FRAME_X_DISPLAY (f)), bgexi_work.display_name) != 0))
+    {
+      illegal_display_p = 1;
+    }
+  else
+    {
+      illegal_display_p = 0;
+    }
+
+
+  /*
+    check bgexid destroy only if !illegal_display_p
+  */
+  if (!illegal_display_p)
+    {
+      int i;
+      for (i = 0;i != BGEXI_OBJECT_LENGTH;i++)
+        {
+          if (bgexi_work.id_list_table[i] &&
+              bgexi_work.id_list_table[i]->trigger_destroy_p)
+            {
+              struct bgexid_unit *unit = bgexi_work.id_list_table[i];
+
+              while (unit)
+                {
+                  struct bgexid_unit *next = unit->next;
+                  BGEXI_DBP ("    destroy %p\n",unit);
+                  if (unit->identifier_type == BGEXID_IDENTIFIER_TYPE_DEFAULT)
+                    {
+                      bgexi_work.default_p = 0;
+                    }
+                  memset (unit, 0, sizeof (*unit));
+                  unit = next;
+                }
+
+              bgexi_destroy (i, f);
+              bgexi_work.id_list_table[i] = 0;
+            }
+        }
+    }
+
+
+  /*
+    get bgexid
+   */
+  bgexid = bgexi_get_bgexid (window);
+  if (bgexid < 0)
+    {
+      BGEXI_DBP ("return by bgexid not found.\n");
+      return 1;
+    }
+
+
+  /*
+    check argument
+  */
+  if ((w < 1) || (h < 1) || (x > 16384) || (y > 8192))
+    {
+      BGEXI_DBP ("Illegal coordinates  xywh:%d,%d,%d,%d  rgba:%p\n",
+                 x, y, w, h,
+                 rgba);
+      if (rgba)
+        {
+          BGEXI_DBP ("    rgba:%d,%d,%d,%d\n",
+                     *(rgba + 0),
+                     *(rgba + 1),
+                     *(rgba + 2),
+                     *(rgba + 3));
+        }
+      else
+        {
+          BGEXI_DBP ("    rgba:0\n");
+        }
+      return 1;
+    }
+
+
+  /*
+    fill color for other display
+   */
+  if (illegal_display_p)
+    return bgexi_fill_color (gc, window,
+                             x, y, w, h, rgba, bgexid);
+
+
+  /*
+    check internal event
+  */
+  if (bgexi_work.trigger_enable_p)
+    {
+      bgexi_work.trigger_enable_p = 0;
+      if ((bgexid == 0) &&
+          (f->bgexi_background_pixmap_p == 0) &&
+          bgexi_work.object[bgexid].fill_pixmap_p &&
+          bgexi_work.fast_background_pixmap_p)
+        {
+          if (!f->bgexi_background_pixmap_p)
+            {
+              XSetWindowBackgroundPixmap (FRAME_X_DISPLAY (f),
+                                          FRAME_X_WINDOW (f),
+                                          bgexi_work.object[bgexid].pixmap);
+              f->bgexi_background_pixmap_p = 1;
+            }
+        }
+    }
+
+  if (bgexi_work.object[bgexid].trigger_restart_p)
+    {
+      bgexi_destroy (bgexid, f);
+      bgexi_create (bgexid, f,
+                    3*65536/4);
+      bgexi_create_image (&bgexi_work.object[bgexid], f, &bgexi_work.object_parameter[bgexid]);
+      if ((bgexid == 0) &&
+          bgexi_work.object[bgexid].fill_pixmap_p &&
+          bgexi_work.fast_background_pixmap_p)
+        {
+          BGEXI_DBP ("    try fill XSetWindowBackgroundPixmap () : bbpp:%d\n",
+                     f->bgexi_background_pixmap_p);
+          if (!f->bgexi_background_pixmap_p)
+            {
+              BGEXI_DBP ("by fill XSetWindowBackgroundPixmap ()\n");
+              XSetWindowBackgroundPixmap (FRAME_X_DISPLAY (f),
+                                          FRAME_X_WINDOW (f),
+                                          bgexi_work.object[bgexid].pixmap);
+              f->bgexi_background_pixmap_p = 1;
+            }
+        }
+    }
+
+  if (bgexi_work.object[bgexid].trigger_destroy_p)
+    {
+      bgexi_work.object[bgexid].trigger_destroy_p = 0;
+      bgexi_destroy (bgexid, f);
+    }
+
+  if (bgexi_work.object[bgexid].trigger_create_p)
+    {
+      bgexi_work.object[bgexid].trigger_create_p = 0;
+      bgexi_create (bgexid, f,
+                   3*65536/4);
+      bgexi_create_image (&bgexi_work.object[bgexid], f, &bgexi_work.object_parameter[bgexid]);
+      if ((bgexid == 0) &&
+          bgexi_work.object[bgexid].fill_pixmap_p &&
+          bgexi_work.fast_background_pixmap_p)
+        {
+          BGEXI_DBP ("    try fill XSetWindowBackgroundPixmap () : bbpp:%d\n",
+                     f->bgexi_background_pixmap_p);
+          if (!f->bgexi_background_pixmap_p)
+            {
+              BGEXI_DBP ("by fill XSetWindowBackgroundPixmap ()\n");
+              XSetWindowBackgroundPixmap (FRAME_X_DISPLAY (f),
+                                          FRAME_X_WINDOW (f),
+                                          bgexi_work.object[bgexid].pixmap);
+              f->bgexi_background_pixmap_p = 1;
+            }
+        }
+    }
+
+
+  /*
+    check flag
+  */
+  if (!bgexi_work.object[bgexid].create_p ||
+      !bgexi_work.object[bgexid].enable_p)
+    {
+      BGEXI_DBP ("return by enable_p:%d or create_p:%d.\n",
+                 bgexi_work.object[bgexid].enable_p,
+                 bgexi_work.object[bgexid].create_p);
+      return 1;
+    }
+
+  if ((bgexid == 0) && bgexi_fast_p () && (rgba == 0))
+    {
+      /* BGEXI_DBP ("return by fast_background_pixmap_p\n"); */
+      /* return 1; */
+    }
+
+  if (!bgexi_work.object[bgexid].dynamic_color_p && rgba)
+    {
+      BGEXI_DBP ("return by dynamic_color_p\n");
+      return 1;
+    }
+
+  if (bgexi_work.object[bgexid].failed_p)
+    {
+      BGEXI_DBP ("global failed_p\n");
+      return 1;
+    }
+
+
+  /*
+    fill color
+   */
+  if (!bgexi_work.object[bgexid].fill_pixmap_p)
+    return bgexi_fill_color (gc, window,
+                             x, y, w, h, rgba, bgexid);
+
+
+  /*
+    render Pixmap
+  */
+  if (bgexi_work.object[bgexid].create_image_p)
+    {
+      int w_block = w / bgexi_work.object[bgexid].width;
+      int h_block = h / bgexi_work.object[bgexid].height;
+      int x_block = x / bgexi_work.object[bgexid].width;
+      int y_block = y / bgexi_work.object[bgexid].height;
+      int ly,lx;
+      XRectangle r1,r2,res;
+
+      r1.x = x;
+      r1.y = y;
+      r1.width = w;
+      r1.height = h;
+      r2.width = bgexi_work.object[bgexid].width;
+      r2.height = bgexi_work.object[bgexid].height;
+
+      for (ly = y_block;ly <= y_block + h_block + 1;ly++)
+        {
+          for (lx = x_block;lx <= x_block + w_block + 1;lx++)
+            {
+              r2.x = lx * bgexi_work.object[bgexid].width;
+              r2.y = ly * bgexi_work.object[bgexid].height;
+              if (bgexi_intersect_rectangles (&r1, &r2, &res))
+                {
+                  BGEXI_DBP ("XCopyArea  xywh:%d,%d,%d,%d\n",
+                             res.x % bgexi_work.object[bgexid].width,
+                             res.y % bgexi_work.object[bgexid].height,
+                             res.width,
+                             res.height);
+                  if (rgba == 0)
+                    {
+                      XCopyArea (FRAME_X_DISPLAY (f), bgexi_work.object[bgexid].pixmap, FRAME_X_DRAWABLE (f), gc,
+                                 res.x % bgexi_work.object[bgexid].width,
+                                 res.y % bgexi_work.object[bgexid].height,
+                                 res.width,
+                                 res.height,
+                                 res.x, res.y);
+                    }
+                  else
+                    {
+                      if ((res.width > 0) &&
+                          (res.height > 0))
+                        {
+                          bgexi_image_convert (f,
+                                               bgexi_work.object[bgexid].image,
+                                               bgexi_work.object[bgexid].work_image,
+                                               rgba,
+                                               bgexi_work.object[bgexid].dynamic_color_factor,
+                                               bgexi_work.object[bgexid].width,
+                                               bgexi_work.object[bgexid].height,
+                                               res.x % bgexi_work.object[bgexid].width,
+                                               res.y % bgexi_work.object[bgexid].height,
+                                               res.width,
+                                               res.height);
+                          XPutImage (FRAME_X_DISPLAY (f),
+                                     FRAME_X_DRAWABLE (f),
+                                     gc,
+                                     bgexi_work.object[bgexid].work_image,
+                                     0,
+                                     0,
+                                     res.x,
+                                     res.y,
+                                     res.width,
+                                     res.height);
+                        }
+                    }
+                }
+            }
+        }
+    }
+  else
+    {
+      BGEXI_DBP ("table failed_p true\n");
+      result = !0;
+    }
+
+  return result;
+}
+
+void
+bgexi_set_overstrike_flag (int overstrike_p)
+{
+  bgexi_work.overstrike_p = overstrike_p;
+}
+
+int
+bgexi_overstrike_p (void)
+{
+  return bgexi_work.overstrike_p;
+}
+
+/*
+
+bgexid lisp function
+
+ */
+DEFUN ("bgexid-create",
+       Fbgexid_create, Sbgexid_create,
+       2, 2, 0,
+       doc: /* Create BGEXID.
+             */)
+     (Lisp_Object lisp_identifier, Lisp_Object lisp_identifier_type)
+{
+  Lisp_Object result = Qnil;
+  char *identifier;
+  int type;
+  int bgexid;
+
+  CHECK_SYMBOL (lisp_identifier_type);
+
+  type = bgexid_get_identifier_type (SSDATA (XSYMBOL (lisp_identifier_type)->u.s.name));
+  if (type == BGEXID_IDENTIFIER_TYPE_ERROR)
+    error ("Invalid symbol.");
+
+  if (type == BGEXID_IDENTIFIER_TYPE_DEFAULT)
+    {
+      identifier = 0;
+    }
+  else
+    {
+      CHECK_STRING (lisp_identifier);
+      identifier = SSDATA (lisp_identifier);
+    }
+
+  bgexid = bgexid_create (identifier, type);
+  if (bgexid >= 0)
+    {
+      XSETINT (result, bgexid);
+    }
+
+  return result;
+}
+
+DEFUN ("bgexid-destroy",
+       Fbgexid_destroy, Sbgexid_destroy,
+       1, 1, 0,
+       doc: /* Destroy BGEXID.
+return Non-nil if error.
+             */)
+     (Lisp_Object lisp_bgexid)
+{
+  Lisp_Object result = Qnil;
+  int bgexid;
+
+  CHECK_NUMBER (lisp_bgexid);
+
+  bgexid = XFIXNUM (lisp_bgexid);
+  if (bgexid_destroy (bgexid))
+    {
+      result = Qt;
+    }
+
+  return result;
+}
+
+DEFUN ("bgexid-get-bgexid-list",
+       Fbgexid_get_bgexid_list, Sbgexid_get_bgexid_list,
+       0, 0, 0,
+       doc: /* get active bgexid list
+             */)
+     (void)
+{
+  Lisp_Object result = Qnil;
+
+  int i;
+  for (i = 0;i != BGEXI_OBJECT_LENGTH;i++)
+    {
+      if (bgexi_work.id_list_table[i] &&
+          bgexi_work.id_list_table[i]->create_p)
+        {
+          Lisp_Object tmp;
+          XSETINT (tmp, i);
+          result = Fcons (tmp, result);
+        }
+    }
+
+  return result;
+}
+
+DEFUN ("bgexid-add",
+       Fbgexid_add, Sbgexid_add,
+       3, 3, 0,
+       doc: /* Add BGEXID.
+return Non-nil if error.
+             */)
+     (Lisp_Object lisp_bgexid, Lisp_Object lisp_identifier, Lisp_Object lisp_identifier_type)
+{
+  Lisp_Object result = Qnil;
+  int bgexid;
+  char *identifier;
+  int type;
+
+  CHECK_NUMBER (lisp_bgexid);
+  CHECK_STRING (lisp_identifier);
+  CHECK_SYMBOL (lisp_identifier_type);
+
+  type = bgexid_get_identifier_type (SSDATA (XSYMBOL (lisp_identifier_type)->u.s.name));
+  if (type == BGEXID_IDENTIFIER_TYPE_ERROR)
+    error ("Invalid symbol.");
+  bgexid = XFIXNUM (lisp_bgexid);
+  identifier = SSDATA (lisp_identifier);
+
+  if (bgexid_add (bgexid, identifier, type))
+    {
+      result = Qt;
+    }
+
+  return result;
+}
+
+DEFUN ("bgexid-delete",
+       Fbgexid_delete, Sbgexid_delete,
+       3, 3, 0,
+       doc: /* Delete BGEXID.
+return Non-nil if error.
+             */)
+     (Lisp_Object lisp_bgexid, Lisp_Object lisp_identifier, Lisp_Object lisp_identifier_type)
+{
+  Lisp_Object result = Qnil;
+  int bgexid;
+  char *identifier;
+  int type;
+
+  CHECK_NUMBER (lisp_bgexid);
+  CHECK_STRING (lisp_identifier);
+  CHECK_SYMBOL (lisp_identifier_type);
+
+  type = bgexid_get_identifier_type (SSDATA (XSYMBOL (lisp_identifier_type)->u.s.name));
+  if (type == BGEXID_IDENTIFIER_TYPE_ERROR)
+    error ("Invalid symbol.");
+  bgexid = XFIXNUM (lisp_bgexid);
+  identifier = SSDATA (lisp_identifier);
+
+  if (bgexid_delete (bgexid, identifier, type))
+    {
+      result = Qt;
+    }
+
+  return result;
+}
+
+DEFUN ("bgexid-get-identifier",
+       Fbgexid_get_identifier, Sbgexid_get_identifier,
+       1, 1, 0,
+       doc: /* get identifier
+             */)
+     (Lisp_Object lisp_bgexid)
+{
+  Lisp_Object result = Qnil;
+  int bgexid;
+
+  CHECK_NUMBER (lisp_bgexid);
+  bgexid = XFIXNUM (lisp_bgexid);
+
+  if (bgexi_work.id_list_table[bgexid] &&
+      bgexi_work.id_list_table[bgexid]->create_p)
+    {
+      struct bgexid_unit *unit = bgexi_work.id_list_table[bgexid];
+      while (unit)
+        {
+          Lisp_Object sym;
+
+          switch (unit->identifier_type)
+            {
+            case BGEXID_IDENTIFIER_TYPE_DEFAULT:
+              sym = intern ("bgex-identifier-type-default");
+              break;
+
+            case BGEXID_IDENTIFIER_TYPE_MAJOR_MODE:
+              sym = intern ("bgex-identifier-type-major-mode");
+              break;
+
+            case BGEXID_IDENTIFIER_TYPE_MAJOR_MODE_REGEXP:
+              sym = intern ("bgex-identifier-type-major-mode-regexp");
+              break;
+
+            case BGEXID_IDENTIFIER_TYPE_BUFFER_NAME:
+              sym = intern ("bgex-identifier-type-buffer-name");
+              break;
+
+            case BGEXID_IDENTIFIER_TYPE_BUFFER_NAME_REGEXP:
+              sym = intern ("bgex-identifier-type-buffer-name-regexp");
+              break;
+
+            default:
+              error ("Fatai:unknown identifier_type");
+              break;
+            }
+          result = Fcons ( Fcons (sym, build_string (unit->identifier)), result);
+
+          unit = unit->next;
+        }
+    }
+
+  return result;
+}
+
+/*
+
+bgex lisp function
+
+ */
+DEFUN ("bgexi-create",
+       Fbgexi_create, Sbgexi_create,
+       4, 5, 0,
+       doc: /* Create BGEX object.
+             */)
+     (Lisp_Object lisp_bgexid, Lisp_Object render_mode, Lisp_Object dynamic_mode, Lisp_Object color, Lisp_Object filename)
+{
+  Lisp_Object result = Qt;
+  int bgexid;
+  int r,g,b;
+
+  CHECK_NUMBER (lisp_bgexid);
+  bgexid = XFIXNUM (lisp_bgexid);
+  if (bgexi_check_bgexid (bgexid))
+    {
+      BGEXI_ERROR_BGEXID (bgexid);
+    }
+  else
+    {
+      int error_p = 0;
+
+      if (NILP (filename))
+        {
+          bgexi_clear_image_filename_parameter (bgexid);
+        }
+      else
+        {
+          CHECK_STRING (filename);
+          if (!(strlen (SSDATA (filename)) < sizeof (bgexi_work.object[0].filename) - 1))
+            {
+              error_p = !0;
+            }
+        }
+
+      if (STRINGP (color))
+        {
+          struct frame *f = SELECTED_FRAME ();
+          if (f && FRAME_X_P (f) && FRAME_LIVE_P (f))
+            {
+              XColor xcolor;
+              if (x_defined_color (f, SSDATA (color), &xcolor, false, false))
+                {
+                  r = xcolor.red;
+                  g = xcolor.green;
+                  b = xcolor.blue;
+                }
+              else
+                {
+                  error ("Illegal color name \"%s\"", SDATA (color));
+                  r = g = b = 0; /* KILLWARNING */
+                }
+            }
+          else
+            {
+              error ("Cant get frame");
+              r = g = b = 0; /* KILLWARNING */
+            }
+        }
+      else
+        {
+          if (XFIXNUM (Flength (color)) != 3)
+            {
+              r = 65535;
+              g = 65535;
+              b = 65535;
+            }
+          else
+            {
+              int tmp[3];
+              int i;
+
+              for (i = 0;i != 3;i++)
+                {
+                  tmp[i] = XFIXNUM (Fnth (make_fixnum (i), color));
+                  if ((tmp[i] < 0) ||
+                      (tmp[i] > 65535))
+                    {
+                      break;
+                    }
+                }
+
+              if (i != 3)
+                {
+                  r = 65535;
+                  g = 65535;
+                  b = 65535;
+                }
+              else
+                {
+                  r = tmp[0];
+                  g = tmp[1];
+                  b = tmp[2];
+                }
+            }
+        }
+
+      BGEXI_DBP ("bgexid:%2d bgexi-create  error:%d\n", bgexid, error_p);
+      if (!error_p &&
+          !bgexi_work.object[bgexid].create_p &&
+          !bgexi_work.object[bgexid].trigger_create_p &&
+          !bgexi_work.object[bgexid].trigger_destroy_p)
+        {
+          int fast_background_pixmap_p = 0;
+          int fill_pixmap_p;
+          int dynamic_color_p;
+          char *parameter_filename = 0;
+          if (NILP (render_mode))
+            {
+              fill_pixmap_p = 0;
+            }
+          else
+            {
+              fill_pixmap_p = !0;
+            }
+          if (NILP (dynamic_mode))
+            {
+              dynamic_color_p = 0;
+            }
+          else
+            {
+              dynamic_color_p = !0;
+            }
+
+          if ((bgexid == 0) &&
+              bgexid_check_identifier_type_default () &&
+              fill_pixmap_p)
+            {
+              fast_background_pixmap_p = 1;
+            }
+
+          if (NILP (filename))
+            {
+            }
+          else
+            {
+              if (strlen (SSDATA (filename)) < sizeof (bgexi_work.object[0].filename) - 1)
+                parameter_filename = SSDATA (filename);
+            }
+
+          result = Qnil;
+          bgexi_set_parameter (bgexid,
+                               fast_background_pixmap_p, dynamic_color_p, fill_pixmap_p,
+                               r, g, b, parameter_filename);
+          bgexi_set_trigger_create (bgexid);
+        }
+    }
+
+  return result;
+}
+
+DEFUN ("bgexi-create-for-xpm-string",
+       Fbgexi_create_for_xpm_string, Sbgexi_create_for_xpm_string,
+       4, 5, 0,
+       doc: /* Create BGEX object for XPM string.
+             */)
+     (Lisp_Object lisp_bgexid, Lisp_Object render_mode, Lisp_Object dynamic_mode, Lisp_Object color, Lisp_Object xpm_string)
+{
+  Lisp_Object result = Qt;
+  int bgexid;
+  int r,g,b;
+
+  CHECK_NUMBER (lisp_bgexid);
+  bgexid = XFIXNUM (lisp_bgexid);
+  if (bgexi_check_bgexid (bgexid))
+    {
+      BGEXI_ERROR_BGEXID (bgexid);
+    }
+  else
+    {
+      int error_p = 0;
+
+      if (NILP (xpm_string))
+        {
+          /* bgexi_clear_image_filename_parameter (bgexid); */
+        }
+      else
+        {
+          CHECK_STRING (xpm_string);
+          /* if (!(strlen (SDATA (filename)) < sizeof (bgexi_work.object[0].filename) - 1)) */
+          /*   { */
+              /* error_p = !0; */
+            /* } */
+        }
+
+      if (STRINGP (color))
+        {
+          struct frame *f = SELECTED_FRAME ();
+          if (f && FRAME_X_P (f) && FRAME_LIVE_P (f))
+            {
+              XColor xcolor;
+              if (x_defined_color (f, SSDATA (color), &xcolor, false, false))
+                {
+                  r = xcolor.red;
+                  g = xcolor.green;
+                  b = xcolor.blue;
+                }
+              else
+                {
+                  error ("Illegal color name \"%s\"", SDATA (color));
+                  r = g = b = 0; /* KILLWARNING */
+                }
+            }
+          else
+            {
+              error ("Cant get frame");
+              r = g = b = 0; /* KILLWARNING */
+            }
+        }
+      else
+        {
+          if (XFIXNUM (Flength (color)) != 3)
+            {
+              r = 65535;
+              g = 65535;
+              b = 65535;
+            }
+          else
+            {
+              int tmp[3];
+              int i;
+
+              for (i = 0;i != 3;i++)
+                {
+                  tmp[i] = XFIXNUM (Fnth (make_fixnum (i), color));
+                  if ((tmp[i] < 0) ||
+                      (tmp[i] > 65535))
+                    {
+                      break;
+                    }
+                }
+
+              if (i != 3)
+                {
+                  r = 65535;
+                  g = 65535;
+                  b = 65535;
+                }
+              else
+                {
+                  r = tmp[0];
+                  g = tmp[1];
+                  b = tmp[2];
+                }
+            }
+        }
+
+      BGEXI_DBP ("bgexid:%2d bgexi-create  error:%d\n", bgexid, error_p);
+      if (!error_p &&
+          !bgexi_work.object[bgexid].create_p &&
+          !bgexi_work.object[bgexid].trigger_create_p &&
+          !bgexi_work.object[bgexid].trigger_destroy_p)
+        {
+          int fast_background_pixmap_p = 0;
+          int fill_pixmap_p;
+          int dynamic_color_p;
+          char *parameter_xpm_string = 0;
+          if (NILP (render_mode))
+            {
+              fill_pixmap_p = 0;
+            }
+          else
+            {
+              fill_pixmap_p = !0;
+            }
+          if (NILP (dynamic_mode))
+            {
+              dynamic_color_p = 0;
+            }
+          else
+            {
+              dynamic_color_p = !0;
+            }
+
+          if ((bgexid == 0) &&
+              bgexid_check_identifier_type_default () &&
+              fill_pixmap_p)
+            {
+              fast_background_pixmap_p = 1;
+            }
+
+          /* if (NILP (filename)) */
+          /*   { */
+          /*   } */
+          /* else */
+          /*   { */
+          /*     if (strlen (SDATA (filename)) < sizeof (bgexi_work.object[0].filename) - 1) */
+          /*       parameter_xpm_string = SDATA (filename); */
+          /*   } */
+          parameter_xpm_string = SSDATA (xpm_string);
+
+          result = Qnil;
+          bgexi_set_parameter_for_xpm_string (bgexid,
+                                              fast_background_pixmap_p, dynamic_color_p, fill_pixmap_p,
+                                              r, g, b, parameter_xpm_string);
+          bgexi_set_trigger_create (bgexid);
+        }
+    }
+
+  return result;
+}
+
+DEFUN ("bgexi-destroy",
+       Fbgexi_destroy, Sbgexi_destroy,
+       1, 1, 0,
+       doc: /* Destroy BGEX object.
+             */)
+     (Lisp_Object lisp_bgexid)
+{
+  Lisp_Object result = Qt;
+  int bgexid;
+
+  CHECK_NUMBER (lisp_bgexid);
+  bgexid = XFIXNUM (lisp_bgexid);
+  if (bgexi_check_bgexid (bgexid))
+    {
+      BGEXI_ERROR_BGEXID (bgexid);
+    }
+  else
+    {
+      if (bgexi_work.object[bgexid].create_p &&
+          !bgexi_work.object[bgexid].trigger_create_p &&
+          !bgexi_work.object[bgexid].trigger_destroy_p)
+        {
+          result = Qnil;
+          bgexi_set_trigger_destroy (bgexid);
+        }
+    }
+
+  return result;
+}
+
+DEFUN ("bgexi-restart",
+       Fbgexi_restart, Sbgexi_restart,
+       4, 5, 0,
+       doc: /* Restart BGEX object.
+             */)
+     (Lisp_Object lisp_bgexid, Lisp_Object render_mode, Lisp_Object dynamic_mode, Lisp_Object color, Lisp_Object filename)
+{
+  Lisp_Object result = Qt;
+  int bgexid;
+  int r,g,b;
+
+  CHECK_NUMBER (lisp_bgexid);
+  bgexid = XFIXNUM (lisp_bgexid);
+  if (bgexi_check_bgexid (bgexid))
+    {
+      BGEXI_ERROR_BGEXID (bgexid);
+    }
+  else
+    {
+      int error_p = 0;
+
+      if (NILP (filename))
+        {
+          bgexi_clear_image_filename_parameter (bgexid);
+        }
+      else
+        {
+          CHECK_STRING (filename);
+          if (!(strlen (SSDATA (filename)) < sizeof (bgexi_work.object[0].filename) - 1))
+            {
+              error_p = !0;
+            }
+        }
+
+      if (STRINGP (color))
+        {
+          struct frame *f = SELECTED_FRAME ();
+          if (f && FRAME_X_P (f) && FRAME_LIVE_P (f))
+            {
+              XColor xcolor;
+              if (x_defined_color (f, SSDATA (color), &xcolor, false, false))
+                {
+                  r = xcolor.red;
+                  g = xcolor.green;
+                  b = xcolor.blue;
+                }
+              else
+                {
+                  error ("Illegal color name \"%s\"", SDATA (color));
+                  r = g = b = 0; /* KILLWARNING */
+                }
+            }
+          else
+            {
+              error ("Cant get frame");
+              r = g = b = 0; /* KILLWARNING */
+            }
+        }
+      else
+        {
+          if (XFIXNUM (Flength (color)) != 3)
+            {
+              r = 65535;
+              g = 65535;
+              b = 65535;
+            }
+          else
+            {
+              int tmp[3];
+              int i;
+
+              for (i = 0;i != 3;i++)
+                {
+                  tmp[i] = XFIXNUM (Fnth (make_fixnum (i), color));
+                  if ((tmp[i] < 0) ||
+                      (tmp[i] > 65535))
+                    {
+                      break;
+                    }
+                }
+
+              if (i != 3)
+                {
+                  r = 65535;
+                  g = 65535;
+                  b = 65535;
+                }
+              else
+                {
+                  r = tmp[0];
+                  g = tmp[1];
+                  b = tmp[2];
+                }
+            }
+        }
+
+      BGEXI_DBP ("bgexi-restart  error:%d\n", error_p);
+      if (!error_p &&
+          bgexi_work.object[bgexid].create_p &&
+          !bgexi_work.object[bgexid].trigger_create_p &&
+          !bgexi_work.object[bgexid].trigger_destroy_p)
+        {
+          int fast_background_pixmap_p = 0;
+          int fill_pixmap_p;
+          int dynamic_color_p;
+          char *parameter_filename = 0;
+          if (NILP (render_mode))
+            {
+              fill_pixmap_p = 0;
+            }
+          else
+            {
+              fill_pixmap_p = !0;
+            }
+          if (NILP (dynamic_mode))
+            {
+              dynamic_color_p = 0;
+            }
+          else
+            {
+              dynamic_color_p = !0;
+            }
+
+          if ((bgexid == 0) &&
+              bgexid_check_identifier_type_default () &&
+              fill_pixmap_p)
+            {
+              fast_background_pixmap_p = 1;
+            }
+
+          if (NILP (filename))
+            {
+            }
+          else
+            {
+              if (strlen (SSDATA (filename)) < sizeof (bgexi_work.object[0].filename) - 1)
+                parameter_filename = SSDATA (filename);
+            }
+
+          result = Qnil;
+          bgexi_set_parameter (bgexid,
+                               fast_background_pixmap_p, dynamic_color_p, fill_pixmap_p,
+                               r, g, b, parameter_filename);
+          bgexi_set_trigger_restart (bgexid);
+        }
+    }
+
+  return result;
+}
+
+DEFUN ("bgexi-restart-for-xpm-string",
+       Fbgexi_restart_for_xpm_string, Sbgexi_restart_for_xpm_string,
+       4, 5, 0,
+       doc: /* Restart BGEX object for XPM string.
+             */)
+     (Lisp_Object lisp_bgexid, Lisp_Object render_mode, Lisp_Object dynamic_mode, Lisp_Object color, Lisp_Object xpm_string)
+{
+  Lisp_Object result = Qt;
+  int bgexid;
+  int r,g,b;
+
+  CHECK_NUMBER (lisp_bgexid);
+  bgexid = XFIXNUM (lisp_bgexid);
+  if (bgexi_check_bgexid (bgexid))
+    {
+      BGEXI_ERROR_BGEXID (bgexid);
+    }
+  else
+    {
+      int error_p = 0;
+
+      if (NILP (xpm_string))
+        {
+          /* FIXME! */
+          /* bgexi_clear_image_filename_parameter (bgexid); */
+        }
+      else
+        {
+          CHECK_STRING (xpm_string);
+          /* if (!(strlen (SDATA (xpm_string)) < sizeof (bgexi_work.object[0].filename) - 1)) */
+          /*   { */
+          /*     error_p = !0; */
+          /*   } */
+        }
+
+      if (STRINGP (color))
+        {
+          struct frame *f = SELECTED_FRAME ();
+          if (f && FRAME_X_P (f) && FRAME_LIVE_P (f))
+            {
+              XColor xcolor;
+              if (x_defined_color (f, SSDATA (color), &xcolor, false, false))
+                {
+                  r = xcolor.red;
+                  g = xcolor.green;
+                  b = xcolor.blue;
+                }
+              else
+                {
+                  error ("Illegal color name \"%s\"", SDATA (color));
+                  r = g = b = 0; /* KILLWARNING */
+                }
+            }
+          else
+            {
+              error ("Cant get frame");
+              r = g = b = 0; /* KILLWARNING */
+            }
+        }
+      else
+        {
+          if (XFIXNUM (Flength (color)) != 3)
+            {
+              r = 65535;
+              g = 65535;
+              b = 65535;
+            }
+          else
+            {
+              int tmp[3];
+              int i;
+
+              for (i = 0;i != 3;i++)
+                {
+                  tmp[i] = XFIXNUM (Fnth (make_fixnum (i), color));
+                  if ((tmp[i] < 0) ||
+                      (tmp[i] > 65535))
+                    {
+                      break;
+                    }
+                }
+
+              if (i != 3)
+                {
+                  r = 65535;
+                  g = 65535;
+                  b = 65535;
+                }
+              else
+                {
+                  r = tmp[0];
+                  g = tmp[1];
+                  b = tmp[2];
+                }
+            }
+        }
+
+      BGEXI_DBP ("bgexi-restart-for-xpm-string  error:%d\n", error_p);
+      if (!error_p &&
+          bgexi_work.object[bgexid].create_p &&
+          !bgexi_work.object[bgexid].trigger_create_p &&
+          !bgexi_work.object[bgexid].trigger_destroy_p)
+        {
+          int fast_background_pixmap_p = 0;
+          int fill_pixmap_p;
+          int dynamic_color_p;
+          char *parameter_xpm_string = 0;
+          if (NILP (render_mode))
+            {
+              fill_pixmap_p = 0;
+            }
+          else
+            {
+              fill_pixmap_p = !0;
+            }
+          if (NILP (dynamic_mode))
+            {
+              dynamic_color_p = 0;
+            }
+          else
+            {
+              dynamic_color_p = !0;
+            }
+
+          if ((bgexid == 0) &&
+              bgexid_check_identifier_type_default () &&
+              fill_pixmap_p)
+            {
+              fast_background_pixmap_p = 1;
+            }
+
+          /* if (NILP (filename)) */
+          /*   { */
+          /*   } */
+          /* else */
+          /*   { */
+          /*     if (strlen (SDATA (filename)) < sizeof (bgexi_work.object[0].filename) - 1) */
+          /*       parameter_filename = SDATA (filename); */
+          /*   } */
+          /* if (!error_p) */
+            {
+              parameter_xpm_string = SSDATA (xpm_string);
+            }
+
+          result = Qnil;
+          bgexi_set_parameter_for_xpm_string (bgexid,
+                                              fast_background_pixmap_p, dynamic_color_p, fill_pixmap_p,
+                                              r, g, b, parameter_xpm_string);
+          bgexi_set_trigger_restart (bgexid);
+        }
+    }
+
+  return result;
+}
+
+DEFUN ("bgexi-enable",
+       Fbgexi_enable, Sbgexi_enable,
+       0, 0, 0,
+       doc: /* enable BGEX
+             */)
+     (void)
+{
+  bgexi_set_disable_flag (0);
+  return Qnil;
+}
+
+DEFUN ("bgexi-disable",
+       Fbgexi_disable, Sbgexi_disable,
+       0, 0, 0,
+       doc: /* disable BGEX
+             */)
+     (void)
+{
+  bgexi_set_disable_flag (1);
+  return Qnil;
+}
+
+DEFUN ("bgexi-set-draw-strict",
+       Fbgexi_set_draw_strict, Sbgexi_set_draw_strict,
+       0, 0, 0,
+       doc: /* set strict draw mode.(default)
+             */)
+     (void)
+{
+  bgexi_set_force_slow_background_pixmap_flag (1);
+  return Qnil;
+}
+
+DEFUN ("bgexi-set-draw-fast",
+       Fbgexi_set_draw_fast, Sbgexi_set_draw_fast,
+       0, 0, 0,
+       doc: /* set fast draw mode.
+             */)
+     (void)
+{
+  bgexi_set_force_slow_background_pixmap_flag (0);
+  return Qnil;
+}
+
+DEFUN ("bgexi-get-bgexid-list",
+       Fbgexi_get_bgexid_list, Sbgexi_get_bgexid_list,
+       0, 0, 0,
+       doc: /* get active bgexid list
+             */)
+     (void)
+{
+  Lisp_Object result = Qnil;
+
+  int i;
+  for (i = 0;i != BGEXI_OBJECT_LENGTH;i++)
+    {
+      if (bgexi_work.object[i].create_p)
+        {
+          Lisp_Object tmp;
+          XSETINT (tmp, i);
+          result = Fcons (tmp, result);
+        }
+    }
+
+  return result;
+}
+
+DEFUN ("bgexi-get-identifier",
+       Fbgexi_get_identifier, Sbgexi_get_identifier,
+       1, 1, 0,
+       doc: /* get identifier
+             */)
+     (Lisp_Object lisp_bgexid)
+{
+  Lisp_Object result = Qnil;
+  int bgexid;
+
+  CHECK_NUMBER (lisp_bgexid);
+  bgexid = XFIXNUM (lisp_bgexid);
+
+  if (bgexi_check_bgexid (bgexid))
+    {
+    }
+  else
+    {
+      if (bgexi_work.id_list_table[bgexid] &&
+          bgexi_work.id_list_table[bgexid]->create_p &&
+          bgexi_work.object[bgexid].create_p &&
+          !bgexi_work.object[bgexid].failed_p)
+        {
+          struct bgexid_unit *unit = bgexi_work.id_list_table[bgexid];
+          while (unit)
+            {
+              Lisp_Object sym;
+
+              switch (unit->identifier_type)
+                {
+                case BGEXID_IDENTIFIER_TYPE_DEFAULT:
+                  sym = intern ("bgex-identifier-type-default");
+                  break;
+
+                case BGEXID_IDENTIFIER_TYPE_MAJOR_MODE:
+                  sym = intern ("bgex-identifier-type-major-mode");
+                  break;
+
+                case BGEXID_IDENTIFIER_TYPE_MAJOR_MODE_REGEXP:
+                  sym = intern ("bgex-identifier-type-major-mode-regexp");
+                  break;
+
+                case BGEXID_IDENTIFIER_TYPE_BUFFER_NAME:
+                  sym = intern ("bgex-identifier-type-buffer-name");
+                  break;
+
+                case BGEXID_IDENTIFIER_TYPE_BUFFER_NAME_REGEXP:
+                  sym = intern ("bgex-identifier-type-buffer-name-regexp");
+                  break;
+
+                default:
+                  error ("Fatai:unknown identifier_type");
+                  break;
+                }
+              result = Fcons ( Fcons (sym, build_string (unit->identifier)), result);
+
+              unit = unit->next;
+            }
+        }
+    }
+
+  return result;
+}
+
+DEFUN ("bgexi-set-active-flag",
+       Fbgexi_set_active_flag, Sbgexi_set_active_flag,
+       2, 2, 0,
+       doc: /* Set active flag.
+             */)
+     (Lisp_Object lisp_bgexid, Lisp_Object flag)
+{
+  Lisp_Object result = Qnil;
+  int bgexid;
+
+  CHECK_NUMBER (lisp_bgexid);
+
+  bgexid = XFIXNUM (lisp_bgexid);
+  if (bgexi_check_bgexid (bgexid))
+    {
+      BGEXI_ERROR_BGEXID (bgexid);
+    }
+  else
+    {
+      result = bgexi_get_active_flag (bgexid) ? Qt : Qnil;
+      bgexi_set_active_flag (bgexid, !NILP (flag));
+    }
+
+  return result;
+}
+
+DEFUN ("bgexi-get-active-flag",
+       Fbgexi_get_active_flag, Sbgexi_get_active_flag,
+       1, 1, 0,
+       doc: /* Return t if BGEX object was enabled.
+             */)
+     (Lisp_Object lisp_bgexid)
+{
+  Lisp_Object result = Qnil;
+  int bgexid;
+
+  CHECK_NUMBER (lisp_bgexid);
+
+  bgexid = XFIXNUM (lisp_bgexid);
+  if (bgexi_check_bgexid (bgexid))
+    {
+      BGEXI_ERROR_BGEXID (bgexid);
+    }
+  else
+    {
+      if (bgexi_get_active_flag (bgexid))
+        {
+          result = Qt;
+        }
+      else
+        {
+          result = Qnil;
+        }
     }
 
-#ifndef USE_XCB
-  x_uncatch_errors ();
-#endif
+  return result;
+}
 
-  unblock_input ();
+DEFUN ("bgexi-get-render-mode",
+       Fbgexi_get_render_mode, Sbgexi_get_render_mode,
+       1, 1, 0,
+       doc: /* Return t if BGEX object was pixmap fill mode.
+             */)
+     (Lisp_Object lisp_bgexid)
+{
+  Lisp_Object result = Qnil;
+  int bgexid;
 
-  if (had_errors) return;
+  CHECK_NUMBER (lisp_bgexid);
 
-  if (x_pixels_diff) *x_pixels_diff = -win_x;
-  if (y_pixels_diff) *y_pixels_diff = -win_y;
+  bgexid = XFIXNUM (lisp_bgexid);
+  if (bgexi_check_bgexid (bgexid))
+    {
+      BGEXI_ERROR_BGEXID (bgexid);
+    }
+  else
+    {
+      if (bgexi_get_render_mode (bgexid))
+        {
+          result = Qt;
+        }
+      else
+        {
+          result = Qnil;
+        }
+    }
 
-  if (left_offset_x) *left_offset_x = -outer_x;
-  if (top_offset_y) *top_offset_y = -outer_y;
+  return result;
+}
 
-  if (xptr) *xptr = real_x;
-  if (yptr) *yptr = real_y;
+DEFUN ("bgexi-set-dynamic-color-flag",
+       Fbgexi_set_dynamic_color_flag, Sbgexi_set_dynamic_color_flag,
+       2, 2, 0,
+       doc: /* Set dynamic color flag.
+             */)
+     (Lisp_Object lisp_bgexid, Lisp_Object flag)
+{
+  Lisp_Object result = Qnil;
+  int bgexid;
 
-  if (outer_border) *outer_border = bw;
+  CHECK_NUMBER (lisp_bgexid);
 
-  if (right_offset_x) *right_offset_x = ow - fw + outer_x;
-  if (bottom_offset_y) *bottom_offset_y = oh - fh + outer_y;
-}
+  bgexid = XFIXNUM (lisp_bgexid);
+  if (bgexi_check_bgexid (bgexid))
+    {
+      BGEXI_ERROR_BGEXID (bgexid);
+    }
+  else
+    {
+      result = bgexi_get_dynamic_color_flag (bgexid) ? Qt : Qnil;
+      bgexi_set_dynamic_color_flag (bgexid, !NILP (flag));
+    }
 
-/* Store the screen positions of frame F into XPTR and YPTR.
-   These are the positions of the containing window manager window,
-   not Emacs's own window.  */
+  return result;
+}
 
-void
-x_real_positions (struct frame *f, int *xptr, int *yptr)
+DEFUN ("bgexi-get-dynamic-color-flag",
+       Fbgexi_get_dynamic_color_flag, Sbgexi_get_dynamic_color_flag,
+       1, 1, 0,
+       doc: /* Return t if dynamic color was enabled.
+             */)
+     (Lisp_Object lisp_bgexid)
 {
-  x_real_pos_and_offsets (f, NULL, NULL, NULL, NULL, NULL, NULL, xptr, yptr,
-                          NULL);
-}
+  Lisp_Object result = Qnil;
+  int bgexid;
 
+  CHECK_NUMBER (lisp_bgexid);
 
-/* Get the mouse position in frame relative coordinates.  */
+  bgexid = XFIXNUM (lisp_bgexid);
+  if (bgexi_check_bgexid (bgexid))
+    {
+      BGEXI_ERROR_BGEXID (bgexid);
+    }
+  else
+    {
+      result = bgexi_get_dynamic_color_flag (bgexid) ? Qt : Qnil;
+    }
 
-void
-x_relative_mouse_position (struct frame *f, int *x, int *y)
-{
-  Window root, dummy_window;
-  int dummy;
+  return result;
+}
 
-  eassert (FRAME_X_P (f));
+DEFUN ("bgexi-set-factor",
+       Fbgexi_set_factor, Sbgexi_set_factor,
+       2, 2, 0,
+       doc: /* Set factor.
+             */)
+     (Lisp_Object lisp_bgexid, Lisp_Object factor)
+{
+  Lisp_Object result = Qnil;
+  int bgexid;
 
-  block_input ();
+  CHECK_NUMBER (lisp_bgexid);
+  CHECK_NUMBER (factor);
 
-  XQueryPointer (FRAME_X_DISPLAY (f),
-                 DefaultRootWindow (FRAME_X_DISPLAY (f)),
+  bgexid = XFIXNUM (lisp_bgexid);
+  if (bgexi_check_bgexid (bgexid))
+    {
+      BGEXI_ERROR_BGEXID (bgexid);
+    }
+  else
+    {
+      XSETINT (result, bgexi_get_dynamic_color_factor (bgexid));
+      bgexi_set_dynamic_color_factor (bgexid, XFIXNUM (factor));
+    }
 
-                 /* The root window which contains the pointer.  */
-                 &root,
+  return result;
+}
 
-                 /* Window pointer is on, not used  */
-                 &dummy_window,
+DEFUN ("bgexi-get-factor",
+       Fbgexi_get_factor, Sbgexi_get_factor,
+       1, 1, 0,
+       doc: /* Get factor.
+             */)
+     (Lisp_Object lisp_bgexid)
+{
+  Lisp_Object result = Qnil;
+  int bgexid;
 
-                 /* The position on that root window.  */
-                 x, y,
+  CHECK_NUMBER (lisp_bgexid);
 
-                 /* x/y in dummy_window coordinates, not used.  */
-                 &dummy, &dummy,
+  bgexid = XFIXNUM (lisp_bgexid);
+  if (bgexi_check_bgexid (bgexid))
+    {
+      BGEXI_ERROR_BGEXID (bgexid);
+    }
+  else
+    {
+      XSETINT (result, bgexi_get_dynamic_color_factor (bgexid));
+    }
 
-                 /* Modifier keys and pointer buttons, about which
-                    we don't care.  */
-                 (unsigned int *) &dummy);
+  return result;
+}
 
-  XTranslateCoordinates (FRAME_X_DISPLAY (f),
+DEFUN ("bgexi-set-color",
+       Fbgexi_set_color, Sbgexi_set_color,
+       2, 2, 0,
+       doc: /* Set color.
+             */)
+     (Lisp_Object lisp_bgexid, Lisp_Object color)
+{
+  Lisp_Object result = Qnil;
+  int bgexid;
 
-                         /* From-window, to-window.  */
-                         FRAME_DISPLAY_INFO (f)->root_window,
-                         FRAME_X_WINDOW (f),
+  CHECK_NUMBER (lisp_bgexid);
 
-                         /* From-position, to-position.  */
-                         *x, *y, x, y,
+  bgexid = XFIXNUM (lisp_bgexid);
+  if (bgexi_check_bgexid (bgexid))
+    {
+      BGEXI_ERROR_BGEXID (bgexid);
+    }
+  else
+    {
+      if (STRINGP (color))
+        {
+          struct frame *f = SELECTED_FRAME ();
+          if (f && FRAME_X_P (f) && FRAME_LIVE_P (f))
+            {
+              XColor xcolor;
+              if (x_defined_color (f, SSDATA (color), &xcolor, false, false))
+                {
+                  bgexi_set_color (bgexid, xcolor.red, xcolor.green, xcolor.blue);
+                }
+              else
+                {
+                  error ("Illegal color name \"%s\"", SDATA (color));
+                }
+            }
+          else
+            {
+              error ("Cant get frame");
+            }
+        }
+      else
+        {
+          if (XFIXNUM (Flength (color)) != 3)
+            {
+              error ("Illegal color");
+            }
+          else
+            {
+              int i;
+              int tmp[3];
+
+              Lisp_Object r, g, b;
+              XSETFASTINT (r, bgexi_work.object[bgexid].r);
+              XSETFASTINT (g, bgexi_work.object[bgexid].g);
+              XSETFASTINT (b, bgexi_work.object[bgexid].b);
+              result = Fcons (r , result);
+              result = Fcons (g , result);
+              result = Fcons (b , result);
+
+              for (i = 0;i != 3;i++)
+                {
+                  tmp[i] = XFIXNUM (Fnth (make_fixnum (i), color));
+                  if ((tmp[i] < 0) ||
+                      (tmp[i] > 65535))
+                    {
+                      break;
+                    }
+                }
+              if (i != 3)
+                {
+                  error ("Illegal color");
+                }
 
-                         /* Child of win.  */
-                         &dummy_window);
+              bgexi_set_color (bgexid, tmp[0], tmp[1], tmp[2]);
+            }
+        }
+    }
 
-  unblock_input ();
+  return result;
 }
 
-/* Gamma-correct COLOR on frame F.  */
-
-void
-gamma_correct (struct frame *f, XColor *color)
+DEFUN ("bgexi-get-color",
+       Fbgexi_get_color, Sbgexi_get_color,
+       1, 1, 0,
+       doc: /* Get color.
+             */)
+     (Lisp_Object lisp_bgexid)
 {
-  if (f->gamma)
+  Lisp_Object result = Qnil;
+  int bgexid;
+
+  CHECK_NUMBER (lisp_bgexid);
+
+  bgexid = XFIXNUM (lisp_bgexid);
+  if (bgexi_check_bgexid (bgexid))
     {
-      color->red = pow (color->red / 65535.0, f->gamma) * 65535.0 + 0.5;
-      color->green = pow (color->green / 65535.0, f->gamma) * 65535.0 + 0.5;
-      color->blue = pow (color->blue / 65535.0, f->gamma) * 65535.0 + 0.5;
+      BGEXI_ERROR_BGEXID (bgexid);
+    }
+  else
+    {
+      Lisp_Object r, g, b;
+      XSETFASTINT (r, bgexi_work.object[bgexid].r);
+      XSETFASTINT (g, bgexi_work.object[bgexid].g);
+      XSETFASTINT (b, bgexi_work.object[bgexid].b);
+      result = Fcons (b , result);
+      result = Fcons (g , result);
+      result = Fcons (r , result);
     }
-}
-
 
-/* Decide if color named COLOR_NAME is valid for use on frame F.  If
-   so, return the RGB values in COLOR.  If ALLOC_P,
-   allocate the color.  Value is false if COLOR_NAME is invalid, or
-   no color could be allocated.  */
+  return result;
+}
 
-bool
-x_defined_color (struct frame *f, const char *color_name,
-		 Emacs_Color *color, bool alloc_p, bool _makeIndex)
+DEFUN ("bgexi-set-image-filename",
+       Fbgexi_set_image_filename, Sbgexi_set_image_filename,
+       2, 2, 0,
+       doc: /* Set image filename and restart BGEX object.
+             */)
+     (Lisp_Object lisp_bgexid, Lisp_Object filename)
 {
-  bool success_p = false;
-  Colormap cmap = FRAME_X_COLORMAP (f);
+  Lisp_Object result = Qnil;
+  int bgexid;
 
-  block_input ();
-#ifdef USE_GTK
-  success_p = xg_check_special_colors (f, color_name, color);
-#endif
-  if (!success_p)
-    success_p = x_parse_color (f, color_name, color) != 0;
-  if (success_p && alloc_p)
-    success_p = x_alloc_nearest_color (f, cmap, color);
-  unblock_input ();
+  CHECK_NUMBER (lisp_bgexid);
 
-  return success_p;
-}
+  bgexid = XFIXNUM (lisp_bgexid);
+  if (bgexi_check_bgexid (bgexid))
+    {
+      BGEXI_ERROR_BGEXID (bgexid);
+    }
+  else
+    {
+      int error = 0;
 
+      result = build_string (bgexi_work.object[bgexid].filename);
 
-/* Return the pixel color value for color COLOR_NAME on frame F.  If F
-   is a monochrome frame, return MONO_COLOR regardless of what ARG says.
-   Signal an error if color can't be allocated.  */
+      if (NILP (filename))
+        {
+          bgexi_clear_image_filename_parameter (bgexid);
+        }
+      else
+        {
+          CHECK_STRING (filename);
+          if (!(strlen (SSDATA (filename)) < sizeof (bgexi_work.object[0].filename) - 1))
+            {
+              error = !0;
+            }
+        }
 
-static int
-x_decode_color (struct frame *f, Lisp_Object color_name, int mono_color)
-{
-  XColor cdef;
+      if (!error)
+        {
+          if (!NILP (filename))
+            strncpy (bgexi_work.object_parameter[bgexid].filename,
+                     SSDATA (filename),
+                     sizeof (bgexi_work.object[0].filename) - 1);
+          bgexi_set_trigger_restart (bgexid);
+        }
+    }
 
-  CHECK_STRING (color_name);
+  return result;
+}
 
-#if false /* Don't do this.  It's wrong when we're not using the default
-	     colormap, it makes freeing difficult, and it's probably not
-	     an important optimization.  */
-  if (strcmp (SDATA (color_name), "black") == 0)
-    return BLACK_PIX_DEFAULT (f);
-  else if (strcmp (SDATA (color_name), "white") == 0)
-    return WHITE_PIX_DEFAULT (f);
-#endif
+DEFUN ("bgexi-get-image-filename",
+       Fbgexi_get_image_filename, Sbgexi_get_image_filename,
+       1, 1, 0,
+       doc: /* Get BGEX image filename.
+             */)
+     (Lisp_Object lisp_bgexid)
+{
+  Lisp_Object result = Qnil;
+  int bgexid;
 
-  /* Return MONO_COLOR for monochrome frames.  */
-  if (FRAME_DISPLAY_INFO (f)->n_planes == 1)
-    return mono_color;
+  CHECK_NUMBER (lisp_bgexid);
 
-  /* x_defined_color is responsible for coping with failures
-     by looking for a near-miss.  */
-  if (x_defined_color (f, SSDATA (color_name), &cdef, true, false))
-    return cdef.pixel;
+  bgexid = XFIXNUM (lisp_bgexid);
+  if (bgexi_check_bgexid (bgexid))
+    {
+      BGEXI_ERROR_BGEXID (bgexid);
+    }
+  else
+    {
+      result = build_string (bgexi_work.object[bgexid].filename);
+    }
 
-  signal_error ("Undefined color", color_name);
+  return result;
 }
 
-
+DEFUN ("bgexi-redraw-window",
+       Fbgexi_redraw_window, Sbgexi_redraw_window,
+       1, 1, 0,
+       doc: /* BGEX redraw.
+             */)
+     (Lisp_Object window)
+{
+  bgexi_redraw_window_internal (XWINDOW (window));
+  return Qnil;
+}
 
 /* Change the `wait-for-wm' frame parameter of frame F.  OLD_VALUE is
    the previous value of that parameter, NEW_VALUE is the new value.
@@ -1583,7 +5344,7 @@ x_set_menu_bar_lines (struct frame *f, Lisp_Object value, Lisp_Object oldval)
 	  y = FRAME_TOP_MARGIN_HEIGHT (f);
 
 	  block_input ();
-	  x_clear_area (f, 0, y, width, height);
+	  x_clear_area (0, f, 0, y, width, height);
 	  unblock_input ();
 	}
 
@@ -1593,7 +5354,7 @@ x_set_menu_bar_lines (struct frame *f, Lisp_Object value, Lisp_Object oldval)
 	  height = nlines * FRAME_LINE_HEIGHT (f) - y;
 
 	  block_input ();
-	  x_clear_area (f, 0, y, width, height);
+	  x_clear_area (0, f, 0, y, width, height);
 	  unblock_input ();
 	}
 
@@ -6556,6 +10317,29 @@ x_create_tip_frame (struct x_display_info *dpyinfo, Lisp_Object parms)
       }
   }
 
+
+  if (bgexi_p (-1) && bgexi_fast_p ())
+    {
+      f->bgexi_background_pixmap_initialized_p = 0;
+      if (bgexi_work.object[0].create_p &&
+          !bgexi_work.object[0].failed_p &&
+          !f->bgexi_background_pixmap_p)
+        {
+          if ((bgexi_work.display_name[0] != '\0') &&
+              (strcmp (DisplayString (FRAME_X_DISPLAY (f)), bgexi_work.display_name) != 0))
+            {
+              f->bgexi_background_pixmap_initialized_p = 1;
+            }
+          else
+            {
+              BGEXI_DBP ("by create frame XSetWindowBackgroundPixmap ()\n");
+              XSetWindowBackgroundPixmap (FRAME_X_DISPLAY (f), FRAME_X_WINDOW (f),
+                                          bgexi_work.object[0].pixmap);
+              f->bgexi_background_pixmap_p = 1;
+            }
+        }
+    }
+
   /* Set up faces after all frame parameters are known.  This call
      also merges in face attributes specified for new frames.
 
@@ -8184,4 +11968,40 @@ syms_of_xfns (void)
 #endif
 #endif
 #endif
+
+  DEFVAR_BOOL ("bgex-exist-p", bgex_exist_p,
+    doc: /* defined means bgex exist. */);
+  bgex_exist_p = true;
+  memset (&bgexi_work, 0, sizeof (bgexi_work));
+  defsubr (&Sbgexid_create);
+  defsubr (&Sbgexid_destroy);
+  defsubr (&Sbgexid_get_bgexid_list);
+  defsubr (&Sbgexid_add);
+  defsubr (&Sbgexid_delete);
+  defsubr (&Sbgexid_get_identifier);
+
+  defsubr (&Sbgexi_create);
+  defsubr (&Sbgexi_create_for_xpm_string);
+  defsubr (&Sbgexi_destroy);
+  defsubr (&Sbgexi_restart);
+  defsubr (&Sbgexi_restart_for_xpm_string);
+  defsubr (&Sbgexi_enable);
+  defsubr (&Sbgexi_disable);
+  defsubr (&Sbgexi_set_draw_strict);
+  defsubr (&Sbgexi_set_draw_fast);
+  defsubr (&Sbgexi_get_bgexid_list);
+  defsubr (&Sbgexi_get_identifier);
+  defsubr (&Sbgexi_set_active_flag);
+  defsubr (&Sbgexi_get_active_flag);
+  defsubr (&Sbgexi_get_render_mode);
+  defsubr (&Sbgexi_set_dynamic_color_flag);
+  defsubr (&Sbgexi_get_dynamic_color_flag);
+  defsubr (&Sbgexi_set_factor);
+  defsubr (&Sbgexi_get_factor);
+  defsubr (&Sbgexi_set_color);
+  defsubr (&Sbgexi_get_color);
+  defsubr (&Sbgexi_set_image_filename);
+  defsubr (&Sbgexi_get_image_filename);
+  defsubr (&Sbgexi_redraw_window);
+  Fbgexi_set_draw_strict ();
 }
diff --git a/src/xfont.c b/src/xfont.c
index 0570ee96a9..e8b0bc39f4 100644
--- a/src/xfont.c
+++ b/src/xfont.c
@@ -45,6 +45,16 @@
 
 /* Prototypes of support functions.  */
 
+extern int bgexi_p (int bgexid);
+extern int bgexi_fast_p (void);
+extern int bgexi_only_fast_p (void);
+extern int bgexi_get_dynamic_color_flag (int bgexid);
+extern int bgexi_get_enable_bgexid (struct window *window);
+extern int bgexi_special_trigger_p (void);
+extern int bgexi_clear_special_trigger_p (void);
+extern int bgexi_fill_rectangle (GC gc, struct window *window,
+                                 int x, int y, int w, int h, int *rgba);
+
 static XCharStruct *xfont_get_pcm (XFontStruct *, unsigned char2b);
 
 /* Get metrics of character CHAR2B in XFONT.  Value is null if CHAR2B
@@ -983,6 +993,178 @@ xfont_text_extents (struct font *font, const unsigned int *code,
   metrics->width = width;
 }
 
+static void
+xfont_draw_bgex_string (char *str, XFontStruct *xfont, int len, GC gc, struct glyph_string *s, int from, int x, int y, bool with_background)
+{
+  Display *display = FRAME_X_DISPLAY (s->f);
+  XGCValues xgcv;
+  int height = xfont->ascent + xfont->descent;
+  int draw_string_p = 0;
+  int draw_image_string_p = 0;
+  XGetGCValues (display, s->gc, GCBackground, &xgcv);
+
+  if (bgexi_only_fast_p () ||
+      (bgexi_fast_p () && (bgexi_get_enable_bgexid (s->w) == 0)))
+    {
+      if (bgexi_get_dynamic_color_flag (0))
+        {
+          if (FRAME_BACKGROUND_PIXEL (s->f) == xgcv.background)
+            {
+              bgexi_fill_rectangle (s->gc, s->w, x, s->y, s->width, s->height, 0);
+              draw_string_p = !0;
+            }
+          else
+            {
+              int rgba[4];
+              XColor xcolor;
+              xcolor.pixel = xgcv.background;
+              XQueryColor (display, FRAME_X_COLORMAP (s->f), &xcolor);
+              rgba[0] = xcolor.red;
+              rgba[1] = xcolor.green;
+              rgba[2] = xcolor.blue;
+              rgba[3] = 0;
+              if ((xgcv.background == 0) ||
+                  bgexi_fill_rectangle (s->gc, s->w,
+                                        x, s->y, s->width, height, rgba))
+                {
+                  draw_image_string_p = !0;
+                }
+              else
+                {
+                  draw_string_p = !0;
+                }
+            }
+        }
+      else
+        {
+          if (FRAME_BACKGROUND_PIXEL (s->f) == xgcv.background)
+            {
+              bgexi_fill_rectangle (s->gc, s->w, x, s->y, s->width, s->height, 0);
+              draw_string_p = !0;
+            }
+          else
+            {
+              draw_image_string_p = !0;
+            }
+        }
+    }
+  else
+    {
+      if (FRAME_BACKGROUND_PIXEL (s->f) == xgcv.background)
+        {
+          if (bgexi_fill_rectangle (s->gc, s->w,
+                                    x, s->y, s->width, height, 0))
+            {
+              draw_image_string_p = !0;
+            }
+          else
+            {
+              draw_string_p = !0;
+            }
+        }
+      else
+        {
+          int rgba[4];
+          XColor xcolor;
+          xcolor.pixel = xgcv.background;
+          XQueryColor (display, FRAME_X_COLORMAP (s->f), &xcolor);
+          rgba[0] = xcolor.red;
+          rgba[1] = xcolor.green;
+          rgba[2] = xcolor.blue;
+          rgba[3] = 0;
+          if (bgexi_fill_rectangle (s->gc, s->w,
+                                    x, s->y, s->width, height, rgba))
+            {
+              draw_image_string_p = !0;
+            }
+          else
+            {
+              draw_string_p = !0;
+            }
+        }
+    }
+  if (str)
+    {
+      int i;
+
+      if (draw_string_p)
+        {
+          if (s->padding_p)
+            for (i = 0; i < len; i++)
+              XDrawString (display, FRAME_X_DRAWABLE (s->f),
+                           gc, x + i, y, str + i, 1);
+          else
+            XDrawString (display, FRAME_X_DRAWABLE (s->f),
+                         gc, x, y, str, len);
+        }
+      else if (draw_image_string_p)
+        {
+          if (s->padding_p)
+            for (i = 0; i < len; i++)
+              XDrawImageString (display, FRAME_X_DRAWABLE (s->f),
+                                gc, x + i, y, str + i, 1);
+          else
+            XDrawImageString (display, FRAME_X_DRAWABLE (s->f),
+                              gc, x, y, str, len);
+        }
+    }
+  else
+    {
+      int i;
+
+      if (draw_string_p)
+        {
+          if (s->padding_p)
+            for (i = 0; i < len; i++)
+              {
+                const unsigned code = s->char2b[from + i];
+                const XChar2b char2b = { .byte1 = code >> 8,
+                  .byte2 = code & 0xFF };
+                XDrawString16 (display, FRAME_X_DRAWABLE (s->f),
+                               gc, x + i, y, &char2b, 1);
+              }
+          else
+            {
+              USE_SAFE_ALLOCA;
+              const unsigned *code = s->char2b + from;
+              XChar2b *char2b;
+              SAFE_NALLOCA (char2b, 1, len);
+              for (int i = 0; i < len; ++i)
+                char2b[i] = (XChar2b) { .byte1 = code[i] >> 8,
+                  .byte2 = code[i] & 0xFF };
+              XDrawString16 (display, FRAME_X_DRAWABLE (s->f),
+                             gc, x, y, char2b, len);
+              SAFE_FREE ();
+            }
+        }
+      else if (draw_image_string_p)
+        {
+          if (s->padding_p)
+            for (i = 0; i < len; i++)
+              {
+                const unsigned code = s->char2b[from + i];
+                const XChar2b char2b = { .byte1 = code >> 8,
+                  .byte2 = code & 0xFF };
+                XDrawImageString16 (display, FRAME_X_DRAWABLE (s->f),
+                                    gc, x + i, y, &char2b, 1);
+              }
+          else
+            {
+              USE_SAFE_ALLOCA;
+              const unsigned *code = s->char2b + from;
+              XChar2b *char2b;
+              SAFE_NALLOCA (char2b, 1, len);
+              for (int i = 0; i < len; ++i)
+                char2b[i] = (XChar2b) { .byte1 = code[i] >> 8,
+                  .byte2 = code[i] & 0xFF };
+              XDrawImageString16 (display, FRAME_X_DRAWABLE (s->f),
+                                  gc, x, y, char2b, len);
+              SAFE_FREE ();
+            }
+        }
+    }
+}
+
 static int
 xfont_draw (struct glyph_string *s, int from, int to, int x, int y,
             bool with_background)
@@ -1007,80 +1189,94 @@ xfont_draw (struct glyph_string *s, int from, int to, int x, int y,
       for (i = 0; i < len ; i++)
 	str[i] = s->char2b[from + i] & 0xFF;
       block_input ();
-      if (with_background)
-	{
-	  if (s->padding_p)
-	    for (i = 0; i < len; i++)
-              XDrawImageString (display, FRAME_X_DRAWABLE (s->f),
-				gc, x + i, y, str + i, 1);
-	  else
-            XDrawImageString (display, FRAME_X_DRAWABLE (s->f),
-			      gc, x, y, str, len);
-	}
+      if (bgexi_p (-1))
+        {
+          xfont_draw_bgex_string(str, xfont, len, gc, s, from, x, y, with_background);
+        }
       else
-	{
-	  if (s->padding_p)
-	    for (i = 0; i < len; i++)
-              XDrawString (display, FRAME_X_DRAWABLE (s->f),
-			   gc, x + i, y, str + i, 1);
-	  else
-            XDrawString (display, FRAME_X_DRAWABLE (s->f),
-			 gc, x, y, str, len);
-	}
+        {
+          if (with_background)
+            {
+              if (s->padding_p)
+                for (i = 0; i < len; i++)
+                  XDrawImageString (display, FRAME_X_DRAWABLE (s->f),
+                                    gc, x + i, y, str + i, 1);
+              else
+                XDrawImageString (display, FRAME_X_DRAWABLE (s->f),
+                                  gc, x, y, str, len);
+            }
+          else
+            {
+              if (s->padding_p)
+                for (i = 0; i < len; i++)
+                  XDrawString (display, FRAME_X_DRAWABLE (s->f),
+                               gc, x + i, y, str + i, 1);
+              else
+                XDrawString (display, FRAME_X_DRAWABLE (s->f),
+                             gc, x, y, str, len);
+            }
+        }
       unblock_input ();
       SAFE_FREE ();
       return s->nchars;
     }
 
   block_input ();
-  if (with_background)
+  if (bgexi_p (-1))
     {
-      if (s->padding_p)
-	for (i = 0; i < len; i++)
-          {
-            const unsigned code = s->char2b[from + i];
-            const XChar2b char2b = { .byte1 = code >> 8,
-                                     .byte2 = code & 0xFF };
-            XDrawImageString16 (display, FRAME_X_DRAWABLE (s->f),
-                                gc, x + i, y, &char2b, 1);
-          }
-      else
-        {
-          USE_SAFE_ALLOCA;
-          const unsigned *code = s->char2b + from;
-          XChar2b *char2b;
-          SAFE_NALLOCA (char2b, 1, len);
-          for (int i = 0; i < len; ++i)
-            char2b[i] = (XChar2b) { .byte1 = code[i] >> 8,
-                                    .byte2 = code[i] & 0xFF };
-          XDrawImageString16 (display, FRAME_X_DRAWABLE (s->f),
-                              gc, x, y, char2b, len);
-          SAFE_FREE ();
-        }
+      xfont_draw_bgex_string(0, xfont, len, gc, s, from, x, y, with_background);
     }
   else
     {
-      if (s->padding_p)
-	for (i = 0; i < len; i++)
-          {
-            const unsigned code = s->char2b[from + i];
-            const XChar2b char2b = { .byte1 = code >> 8,
-                                     .byte2 = code & 0xFF };
-            XDrawString16 (display, FRAME_X_DRAWABLE (s->f),
-                           gc, x + i, y, &char2b, 1);
-          }
+      if (with_background)
+        {
+          if (s->padding_p)
+            for (i = 0; i < len; i++)
+              {
+                const unsigned code = s->char2b[from + i];
+                const XChar2b char2b = { .byte1 = code >> 8,
+                  .byte2 = code & 0xFF };
+                XDrawImageString16 (display, FRAME_X_DRAWABLE (s->f),
+                                    gc, x + i, y, &char2b, 1);
+              }
+          else
+            {
+              USE_SAFE_ALLOCA;
+              const unsigned *code = s->char2b + from;
+              XChar2b *char2b;
+              SAFE_NALLOCA (char2b, 1, len);
+              for (int i = 0; i < len; ++i)
+                char2b[i] = (XChar2b) { .byte1 = code[i] >> 8,
+                  .byte2 = code[i] & 0xFF };
+              XDrawImageString16 (display, FRAME_X_DRAWABLE (s->f),
+                                  gc, x, y, char2b, len);
+              SAFE_FREE ();
+            }
+        }
       else
         {
-          USE_SAFE_ALLOCA;
-          const unsigned *code = s->char2b + from;
-          XChar2b *char2b;
-          SAFE_NALLOCA (char2b, 1, len);
-          for (int i = 0; i < len; ++i)
-            char2b[i] = (XChar2b) { .byte1 = code[i] >> 8,
-                                    .byte2 = code[i] & 0xFF };
-          XDrawString16 (display, FRAME_X_DRAWABLE (s->f),
-                         gc, x, y, char2b, len);
-          SAFE_FREE ();
+          if (s->padding_p)
+            for (i = 0; i < len; i++)
+              {
+                const unsigned code = s->char2b[from + i];
+                const XChar2b char2b = { .byte1 = code >> 8,
+                  .byte2 = code & 0xFF };
+                XDrawString16 (display, FRAME_X_DRAWABLE (s->f),
+                               gc, x + i, y, &char2b, 1);
+              }
+          else
+            {
+              USE_SAFE_ALLOCA;
+              const unsigned *code = s->char2b + from;
+              XChar2b *char2b;
+              SAFE_NALLOCA (char2b, 1, len);
+              for (int i = 0; i < len; ++i)
+                char2b[i] = (XChar2b) { .byte1 = code[i] >> 8,
+                  .byte2 = code[i] & 0xFF };
+              XDrawString16 (display, FRAME_X_DRAWABLE (s->f),
+                             gc, x, y, char2b, len);
+              SAFE_FREE ();
+            }
         }
     }
   unblock_input ();
diff --git a/src/xftfont.c b/src/xftfont.c
index f734931636..d24e95e8dc 100644
--- a/src/xftfont.c
+++ b/src/xftfont.c
@@ -116,6 +116,16 @@ xftfont_match (struct frame *f, Lisp_Object spec)
   return ftfont_match2 (f, spec, Qxft);
 }
 
+extern int bgexi_p (int bgexid);
+extern int bgexi_fast_p (void);
+extern int bgexi_only_fast_p (void);
+extern int bgexi_get_dynamic_color_flag (int bgexid);
+extern int bgexi_get_enable_bgexid (struct window *window);
+extern int bgexi_clear_special_trigger_p (void);
+extern int bgexi_fill_rectangle (GC gc, struct window *window,
+                                 int x, int y, int w, int h, int *rgba);
+extern int bgexi_overstrike_p (void);
+
 static FcChar8 ascii_printable[95];
 
 static Lisp_Object
@@ -453,6 +463,7 @@ xftfont_draw (struct glyph_string *s, int from, int to, int x, int y,
   block_input ();
 
   struct frame *f = s->f;
+  Display *display = FRAME_X_DISPLAY (f);
   struct face *face = s->face;
   struct font_info *xftfont_info = (struct font_info *) s->font;
   struct xftface_info *xftface_info = NULL;
@@ -461,6 +472,22 @@ xftfont_draw (struct glyph_string *s, int from, int to, int x, int y,
   XftColor fg, bg;
   int len = to - from;
   int i;
+  int height = FONT_HEIGHT (s->font), ascent = FONT_BASE (s->font);
+  /* Font's global height and ascent values might be
+     preposterously large for some fonts.  We fix here the case
+     when those fonts are used for display of glyphless
+     characters, because drawing background with font dimensions
+     in those cases makes the display illegible.  There's only one
+     more call to the draw method with with_background set to
+     true, and that's in x_draw_glyph_string_foreground, when
+     drawing the cursor, where we have no such heuristics
+     available.  FIXME.  */
+  if (s->first_glyph->type == GLYPHLESS_GLYPH
+      && (s->first_glyph->u.glyphless.method == GLYPHLESS_DISPLAY_HEX_CODE
+          || s->first_glyph->u.glyphless.method == GLYPHLESS_DISPLAY_ACRONYM))
+    height = ascent =
+      s->first_glyph->slice.glyphless.lower_yoff
+      - s->first_glyph->slice.glyphless.upper_yoff;
 
   if (s->font == face->font)
     xftface_info = (struct xftface_info *) face->extra;
@@ -471,26 +498,85 @@ xftfont_draw (struct glyph_string *s, int from, int to, int x, int y,
   else
     XftDrawSetClip (xft_draw, NULL);
 
-  if (with_background)
+  if (bgexi_p (-1) &&
+      !bgexi_overstrike_p())
+    {
+      XGCValues xgcv;
+      int draw_rect_p = 0;
+      int fill_rect_p = 0;
+      XGetGCValues (display, s->gc, GCBackground, &xgcv);
+      if (bgexi_only_fast_p () ||
+          (bgexi_fast_p () && (bgexi_get_enable_bgexid (s->w) == 0)))
+        {
+          if (bgexi_get_dynamic_color_flag (0))
+            {
+              if (FRAME_BACKGROUND_PIXEL (s->f) == xgcv.background)
+                {
+                  bgexi_fill_rectangle (s->gc, s->w, x, y - ascent, s->width, height, 0);
+                }
+              else
+                {
+                  fill_rect_p = !0;
+                }
+            }
+          else
+            {
+              if (FRAME_BACKGROUND_PIXEL (s->f) == xgcv.background)
+                {
+                  bgexi_fill_rectangle (s->gc, s->w, x, y - ascent, s->width, height, 0);
+                }
+              else
+                {
+                  fill_rect_p = !0;
+                }
+            }
+        }
+      else
+        {
+          if (FRAME_BACKGROUND_PIXEL (s->f) == xgcv.background)
+            {
+              if (bgexi_fill_rectangle (s->gc, s->w, x, y - ascent, s->width, height, 0))
+                {
+                  draw_rect_p = !0;
+                }
+              else
+                {
+                }
+            }
+          else
+            {
+              fill_rect_p = !0;
+            }
+        }
+      if (fill_rect_p)
+        {
+          int rgba[4];
+          XColor xcolor;
+          xcolor.pixel = xgcv.background;
+          XQueryColor (display, FRAME_X_COLORMAP (s->f), &xcolor);
+          rgba[0] = xcolor.red;
+          rgba[1] = xcolor.green;
+          rgba[2] = xcolor.blue;
+          rgba[3] = 0;
+          if (s->face->box_horizontal_line_width == 0)
+            {
+              if ((xgcv.background == 0) ||
+                  bgexi_fill_rectangle (s->gc, s->w, x, y - ascent, s->width, height, rgba))
+                {
+                  draw_rect_p = !0;
+                }
+              else
+                {
+                }
+            }
+        }
+      if (draw_rect_p && with_background)
+        XftDrawRect (xft_draw, &bg, x, y - ascent, s->width, height);
+    }
+  else
     {
-      int height = FONT_HEIGHT (s->font), ascent = FONT_BASE (s->font);
-
-      /* Font's global height and ascent values might be
-	 preposterously large for some fonts.  We fix here the case
-	 when those fonts are used for display of glyphless
-	 characters, because drawing background with font dimensions
-	 in those cases makes the display illegible.  There's only one
-	 more call to the draw method with with_background set to
-	 true, and that's in x_draw_glyph_string_foreground, when
-	 drawing the cursor, where we have no such heuristics
-	 available.  FIXME.  */
-      if (s->first_glyph->type == GLYPHLESS_GLYPH
-	  && (s->first_glyph->u.glyphless.method == GLYPHLESS_DISPLAY_HEX_CODE
-	      || s->first_glyph->u.glyphless.method == GLYPHLESS_DISPLAY_ACRONYM))
-	height = ascent =
-	  s->first_glyph->slice.glyphless.lower_yoff
-	  - s->first_glyph->slice.glyphless.upper_yoff;
-      XftDrawRect (xft_draw, &bg, x, y - ascent, s->width, height);
+      if (with_background)
+        XftDrawRect (xft_draw, &bg, x, y - ascent, s->width, height);
     }
   code = alloca (sizeof (FT_UInt) * len);
   for (i = 0; i < len; i++)
diff --git a/src/xterm.c b/src/xterm.c
index 744b80c68a..57e1b4868c 100644
--- a/src/xterm.c
+++ b/src/xterm.c
@@ -235,6 +235,17 @@ #define XtNinitialState "initialState"
 
 static bool x_get_current_wm_state (struct frame *, Window, int *, bool *);
 
+extern bool expose_window (struct window *w, const Emacs_Rectangle *fr);
+extern int bgexi_p (int bgexid);
+extern int bgexi_fast_p (void);
+extern int bgexi_only_fast_p (void);
+extern int bgexi_get_dynamic_color_flag (int bgexid);
+extern int bgexi_get_enable_bgexid (struct window *window);
+extern int bgexi_special_trigger_p (struct window *window);
+extern int bgexi_clear_special_trigger_p (void);
+extern int bgexi_fill_rectangle (GC gc, struct window *window,
+                                 int x, int y, int w, int h, int *rgba);
+extern void bgexi_set_overstrike_flag (int overstrike_p);
 /* Flush display of frame F.  */
 
 static void
@@ -648,7 +659,7 @@ x_cr_draw_frame (cairo_t *cr, struct frame *f)
 
   cairo_t *saved_cr = FRAME_CR_CONTEXT (f);
   FRAME_CR_CONTEXT (f) = cr;
-  x_clear_area (f, 0, 0, width, height);
+  x_clear_area (0, f, 0, 0, width, height);
   expose_frame (f, 0, 0, width, height);
   FRAME_CR_CONTEXT (f) = saved_cr;
 }
@@ -731,7 +742,7 @@ x_cr_export_frames (Lisp_Object frames, cairo_surface_type_t surface_type)
     {
       cairo_t *saved_cr = FRAME_CR_CONTEXT (f);
       FRAME_CR_CONTEXT (f) = cr;
-      x_clear_area (f, 0, 0, width, height);
+      x_clear_area (0, f, 0, 0, width, height);
       expose_frame (f, 0, 0, width, height);
       FRAME_CR_CONTEXT (f) = saved_cr;
 
@@ -798,7 +809,7 @@ x_reset_clip_rectangles (struct frame *f, GC gc)
 }
 
 static void
-x_fill_rectangle (struct frame *f, GC gc, int x, int y, int width, int height)
+x_fill_rectangle (struct frame *f, GC gc, int x, int y, int width, int height, struct window *emacs_window)
 {
 #ifdef USE_CAIRO
   Display *dpy = FRAME_X_DISPLAY (f);
@@ -806,7 +817,7 @@ x_fill_rectangle (struct frame *f, GC gc, int x, int y, int width, int height)
   XGCValues xgcv;
 
   cr = x_begin_cr_clip (f, gc);
-  XGetGCValues (dpy, gc, GCFillStyle | GCStipple, &xgcv);
+  XGetGCValues (dpy, gc, GCFillStyle | GCStipple | GCBackground, &xgcv);
   if (xgcv.fill_style == FillSolid
       /* Invalid resource ID (one or more of the three most
 	 significant bits set to 1) is obtained if the GCStipple
@@ -814,9 +825,69 @@ x_fill_rectangle (struct frame *f, GC gc, int x, int y, int width, int height)
 	 regarded as Pixmap of unspecified size filled with ones.  */
       || (xgcv.stipple & ((Pixmap) 7 << (sizeof (Pixmap) * CHAR_BIT - 3))))
     {
-      x_set_cr_source_with_gc_foreground (f, gc);
-      cairo_rectangle (cr, x, y, width, height);
-      cairo_fill (cr);
+      if (emacs_window)
+	{
+	  int enable_bgexid = bgexi_get_enable_bgexid (emacs_window);
+	  if (bgexi_fast_p () &&
+	      (enable_bgexid == 0) &&
+	      !bgexi_get_dynamic_color_flag (0))
+	    {
+	      if (FRAME_BACKGROUND_PIXEL (f) == xgcv.background)
+		{
+		  bgexi_fill_rectangle (gc, emacs_window, x, y, width, height, 0);
+		}
+	      else
+		{
+		  x_set_cr_source_with_gc_foreground (f, gc);
+		  cairo_rectangle (cr, x, y, width, height);
+		  cairo_fill (cr);
+		}
+	    }
+	  else
+	    {
+	      int flag = 1;
+
+	      if (FRAME_BACKGROUND_PIXEL (f) == xgcv.background)
+		{
+		  if (bgexi_fast_p () &&
+		      (enable_bgexid == 0) &&
+		      bgexi_get_dynamic_color_flag (0))
+		    {
+		      bgexi_fill_rectangle (gc, emacs_window, x, y, width, height, 0);
+		      flag = 0;
+		    }
+		  else
+		    {
+		      flag = bgexi_fill_rectangle (gc, emacs_window, x, y, width, height, 0);
+		    }
+		}
+	      else
+		{
+		  int rgba[4];
+		  static XColor xcolor;
+		  xcolor.pixel = xgcv.background;
+		  XQueryColor (dpy, FRAME_X_COLORMAP (f), &xcolor);
+		  rgba[0] = xcolor.red;
+		  rgba[1] = xcolor.green;
+		  rgba[2] = xcolor.blue;
+		  rgba[3] = 0;
+		  flag = bgexi_fill_rectangle (gc, emacs_window, x, y, width, height, rgba);
+		}
+
+	      if (flag)
+		{
+		  x_set_cr_source_with_gc_foreground (f, gc);
+		  cairo_rectangle (cr, x, y, width, height);
+		  cairo_fill (cr);
+		}
+	    }
+	}
+      else
+	{
+	  x_set_cr_source_with_gc_foreground (f, gc);
+	  cairo_rectangle (cr, x, y, width, height);
+	  cairo_fill (cr);
+	}
     }
   else
     {
@@ -871,7 +942,7 @@ x_clear_window (struct frame *f)
   x_end_cr_clip (f);
 #else
   if (FRAME_X_DOUBLE_BUFFERED_P (f))
-    x_clear_area (f, 0, 0, FRAME_PIXEL_WIDTH (f), FRAME_PIXEL_HEIGHT (f));
+    x_clear_area (0, f, 0, 0, FRAME_PIXEL_WIDTH (f), FRAME_PIXEL_HEIGHT (f));
   else
     XClearWindow (FRAME_X_DISPLAY (f), FRAME_X_WINDOW (f));
 #endif
@@ -1125,7 +1196,7 @@ x_draw_vertical_window_border (struct window *w, int x, int y0, int y1)
 		    face->foreground);
 
 #ifdef USE_CAIRO
-  x_fill_rectangle (f, f->output_data.x->normal_gc, x, y0, 1, y1 - y0);
+  x_fill_rectangle (f, f->output_data.x->normal_gc, x, y0, 1, y1 - y0, w);
 #else
   XDrawLine (FRAME_X_DISPLAY (f), FRAME_X_DRAWABLE (f),
 	     f->output_data.x->normal_gc, x, y0, x, y1);
@@ -1158,13 +1229,13 @@ x_draw_window_divider (struct window *w, int x0, int x1, int y0, int y1)
     {
       XSetForeground (display, f->output_data.x->normal_gc, color_first);
       x_fill_rectangle (f, f->output_data.x->normal_gc,
-			x0, y0, 1, y1 - y0);
+			x0, y0, 1, y1 - y0, w);
       XSetForeground (display, f->output_data.x->normal_gc, color);
       x_fill_rectangle (f, f->output_data.x->normal_gc,
-			x0 + 1, y0, x1 - x0 - 2, y1 - y0);
+			x0 + 1, y0, x1 - x0 - 2, y1 - y0, w);
       XSetForeground (display, f->output_data.x->normal_gc, color_last);
       x_fill_rectangle (f, f->output_data.x->normal_gc,
-			x1 - 1, y0, 1, y1 - y0);
+			x1 - 1, y0, 1, y1 - y0, w);
     }
   else if ((x1 - x0 > y1 - y0) && (y1 - y0 >= 3))
     /* A horizontal divider, at least three pixels high: Draw first and
@@ -1172,13 +1243,13 @@ x_draw_window_divider (struct window *w, int x0, int x1, int y0, int y1)
     {
       XSetForeground (display, f->output_data.x->normal_gc, color_first);
       x_fill_rectangle (f, f->output_data.x->normal_gc,
-			x0, y0, x1 - x0, 1);
+			x0, y0, x1 - x0, 1, w);
       XSetForeground (display, f->output_data.x->normal_gc, color);
       x_fill_rectangle (f, f->output_data.x->normal_gc,
-			x0, y0 + 1, x1 - x0, y1 - y0 - 2);
+			x0, y0 + 1, x1 - x0, y1 - y0 - 2, w);
       XSetForeground (display, f->output_data.x->normal_gc, color_last);
       x_fill_rectangle (f, f->output_data.x->normal_gc,
-			x0, y1 - 1, x1 - x0, 1);
+			x0, y1 - 1, x1 - x0, 1, w);
     }
   else
     {
@@ -1186,7 +1257,7 @@ x_draw_window_divider (struct window *w, int x0, int x1, int y0, int y1)
        differently.  */
       XSetForeground (display, f->output_data.x->normal_gc, color);
       x_fill_rectangle (f, f->output_data.x->normal_gc,
-			x0, y0, x1 - x0, y1 - y0);
+			x0, y0, x1 - x0, y1 - y0, w);
     }
 }
 
@@ -1311,18 +1382,18 @@ x_clear_under_internal_border (struct frame *f)
 	  GC gc = f->output_data.x->normal_gc;
 
 	  XSetForeground (display, gc, color);
-	  x_fill_rectangle (f, gc, 0, margin, width, border);
-	  x_fill_rectangle (f, gc, 0, 0, border, height);
-	  x_fill_rectangle (f, gc, width - border, 0, border, height);
-	  x_fill_rectangle (f, gc, 0, height - border, width, border);
+	  x_fill_rectangle (f, gc, 0, margin, width, border, 0);
+	  x_fill_rectangle (f, gc, 0, 0, border, height, 0);
+	  x_fill_rectangle (f, gc, width - border, 0, border, height, 0);
+	  x_fill_rectangle (f, gc, 0, height - border, width, border, 0);
 	  XSetForeground (display, gc, FRAME_FOREGROUND_PIXEL (f));
 	}
       else
 	{
-	  x_clear_area (f, 0, 0, border, height);
-	  x_clear_area (f, 0, margin, width, border);
-	  x_clear_area (f, width - border, 0, border, height);
-	  x_clear_area (f, 0, height - border, width, border);
+	  x_clear_area (0, f, 0, 0, border, height);
+	  x_clear_area (0, f, 0, margin, width, border);
+	  x_clear_area (0, f, width - border, 0, border, height);
+	  x_clear_area (0, f, 0, height - border, width, border);
 	}
 
       unblock_input ();
@@ -1381,15 +1452,15 @@ x_after_update_window_line (struct window *w, struct glyph_row *desired_row)
 	    GC gc = f->output_data.x->normal_gc;
 
 	    XSetForeground (display, gc, color);
-	    x_fill_rectangle (f, gc, 0, y, width, height);
+	    x_fill_rectangle (f, gc, 0, y, width, height, w);
 	    x_fill_rectangle (f, gc, FRAME_PIXEL_WIDTH (f) - width, y,
-			      width, height);
+			      width, height, w);
 	    XSetForeground (display, gc, FRAME_FOREGROUND_PIXEL (f));
 	  }
 	else
 	  {
-	    x_clear_area (f, 0, y, width, height);
-	    x_clear_area (f, FRAME_PIXEL_WIDTH (f) - width, y, width, height);
+	    x_clear_area (w, f, 0, y, width, height);
+	    x_clear_area (w, f, FRAME_PIXEL_WIDTH (f) - width, y, width, height);
 	  }
 	unblock_input ();
       }
@@ -1419,7 +1490,7 @@ x_draw_fringe_bitmap (struct window *w, struct glyph_row *row, struct draw_fring
       else
 	XSetForeground (display, face->gc, face->background);
 
-      x_fill_rectangle (f, face->gc, p->bx, p->by, p->nx, p->ny);
+      x_fill_rectangle (f, face->gc, p->bx, p->by, p->nx, p->ny, w);
 
       if (!face->stipple)
 	XSetForeground (display, face->gc, face->foreground);
@@ -1740,7 +1811,63 @@ x_clear_glyph_string_rect (struct glyph_string *s, int x, int y, int w, int h)
   XGCValues xgcv;
   XGetGCValues (display, s->gc, GCForeground | GCBackground, &xgcv);
   XSetForeground (display, s->gc, xgcv.background);
-  x_fill_rectangle (s->f, s->gc, x, y, w, h);
+  if (bgexi_p (-1))
+    {
+      int enable_bgexid = bgexi_get_enable_bgexid (s->w);
+      if (bgexi_fast_p () &&
+          (enable_bgexid == 0) &&
+          !bgexi_get_dynamic_color_flag (0))
+        {
+          if (FRAME_BACKGROUND_PIXEL (s->f) == xgcv.background)
+            {
+              bgexi_fill_rectangle (s->gc, s->w, x, y, w, h, 0);
+            }
+          else
+            {
+              x_fill_rectangle (s->f, s->gc, x, y, w, h, 0);
+            }
+        }
+      else
+        {
+          int flag = 1;
+
+          if (FRAME_BACKGROUND_PIXEL (s->f) == xgcv.background)
+            {
+              if (bgexi_fast_p () &&
+                  (enable_bgexid == 0) &&
+                  bgexi_get_dynamic_color_flag (0))
+                {
+                  bgexi_fill_rectangle (s->gc, s->w, x, y, w, h, 0);
+                  flag = 0;
+                }
+              else
+                {
+                  flag = bgexi_fill_rectangle (s->gc, s->w, x, y, w, h, 0);
+                }
+            }
+          else
+            {
+              int rgba[4];
+              XColor xcolor;
+              xcolor.pixel = xgcv.background;
+              XQueryColor (display, FRAME_X_COLORMAP (s->f), &xcolor);
+              rgba[0] = xcolor.red;
+              rgba[1] = xcolor.green;
+              rgba[2] = xcolor.blue;
+              rgba[3] = 0;
+              flag = bgexi_fill_rectangle (s->gc, s->w, x, y, w, h, rgba);
+            }
+
+          if (flag)
+            {
+              x_fill_rectangle (s->f, s->gc, x, y, w, h, 0);
+            }
+        }
+    }
+  else
+    {
+      x_fill_rectangle (s->f, s->gc, x, y, w, h, 0);
+    }
   XSetForeground (display, s->gc, xgcv.foreground);
 }
 
@@ -1769,7 +1896,8 @@ x_draw_glyph_string_background (struct glyph_string *s, bool force_p)
 	  x_fill_rectangle (s->f, s->gc, s->x,
 			  s->y + box_line_width,
 			  s->background_width,
-			  s->height - 2 * box_line_width);
+			  s->height - 2 * box_line_width,
+			  s->w);
 	  XSetFillStyle (display, s->gc, FillSolid);
 	  s->background_filled_p = true;
 	}
@@ -1841,7 +1969,11 @@ x_draw_glyph_string_foreground (struct glyph_string *s)
 	  else
 	    font->driver->draw (s, 0, s->nchars, x, y, true);
 	  if (s->face->overstrike)
-	    font->driver->draw (s, 0, s->nchars, x + 1, y, false);
+            {
+              bgexi_set_overstrike_flag (1);
+              font->driver->draw (s, 0, s->nchars, x + 1, y, false);
+              bgexi_set_overstrike_flag (0);
+            }
 #ifdef USE_CAIRO
 	  if (EQ (font->driver->type, Qx))
 	    x_end_cr_xlib_drawable (s->f, s->gc);
@@ -1864,7 +1996,8 @@ x_draw_glyph_string_foreground (struct glyph_string *s)
 		  x_fill_rectangle (s->f, s->gc, s->x,
 				    s->y + box_line_width,
 				    s->background_width,
-				    s->height - 2 * box_line_width);
+				    s->height - 2 * box_line_width,
+				    s->w);
 		  XSetFillStyle (display, s->gc, FillSolid);
 		}
 	      else
@@ -2775,7 +2908,7 @@ x_draw_relief_rect (struct frame *f,
   if (left_p)
     {
       x_fill_rectangle (f, top_left_gc, left_x, top_y,
-			vwidth, bottom_y + 1 - top_y);
+			vwidth, bottom_y + 1 - top_y, 0);
       if (top_p)
 	corners |= 1 << CORNER_TOP_LEFT;
       if (bot_p)
@@ -2784,7 +2917,7 @@ x_draw_relief_rect (struct frame *f,
   if (right_p)
     {
       x_fill_rectangle (f, bottom_right_gc, right_x + 1 - vwidth, top_y,
-			vwidth, bottom_y + 1 - top_y);
+			vwidth, bottom_y + 1 - top_y, 0);
       if (top_p)
 	corners |= 1 << CORNER_TOP_RIGHT;
       if (bot_p)
@@ -2794,7 +2927,7 @@ x_draw_relief_rect (struct frame *f,
     {
       if (!right_p)
 	x_fill_rectangle (f, top_left_gc, left_x, top_y,
-			  right_x + 1 - left_x, hwidth);
+			  right_x + 1 - left_x, hwidth, 0);
       else
 	x_fill_trapezoid_for_relief (f, top_left_gc, left_x, top_y,
 				     right_x + 1 - left_x, hwidth, 1);
@@ -2803,7 +2936,7 @@ x_draw_relief_rect (struct frame *f,
     {
       if (!left_p)
 	x_fill_rectangle (f, bottom_right_gc, left_x, bottom_y + 1 - hwidth,
-			  right_x + 1 - left_x, hwidth);
+			  right_x + 1 - left_x, hwidth, 0);
       else
 	x_fill_trapezoid_for_relief (f, bottom_right_gc,
 				     left_x, bottom_y + 1 - hwidth,
@@ -2811,10 +2944,10 @@ x_draw_relief_rect (struct frame *f,
     }
   if (left_p && vwidth > 1)
     x_fill_rectangle (f, bottom_right_gc, left_x, top_y,
-		      1, bottom_y + 1 - top_y);
+		      1, bottom_y + 1 - top_y, 0);
   if (top_p && hwidth > 1)
     x_fill_rectangle (f, bottom_right_gc, left_x, top_y,
-		      right_x + 1 - left_x, 1);
+		      right_x + 1 - left_x, 1, 0);
   if (corners)
     {
       XSetBackground (FRAME_X_DISPLAY (f), top_left_gc,
@@ -2936,21 +3069,21 @@ x_draw_box_rect (struct glyph_string *s,
 
   /* Top.  */
   x_fill_rectangle (s->f, s->gc,
-		  left_x, top_y, right_x - left_x + 1, hwidth);
+		  left_x, top_y, right_x - left_x + 1, hwidth, s->w);
 
   /* Left.  */
   if (left_p)
     x_fill_rectangle (s->f, s->gc,
-		    left_x, top_y, vwidth, bottom_y - top_y + 1);
+		    left_x, top_y, vwidth, bottom_y - top_y + 1, s->w);
 
   /* Bottom.  */
   x_fill_rectangle (s->f, s->gc,
-		  left_x, bottom_y - hwidth + 1, right_x - left_x + 1, hwidth);
+		  left_x, bottom_y - hwidth + 1, right_x - left_x + 1, hwidth, s->w);
 
   /* Right.  */
   if (right_p)
     x_fill_rectangle (s->f, s->gc,
-		    right_x - vwidth + 1, top_y, vwidth, bottom_y - top_y + 1);
+		    right_x - vwidth + 1, top_y, vwidth, bottom_y - top_y + 1, s->w);
 
   XSetForeground (display, s->gc, xgcv.foreground);
   x_reset_clip_rectangles (s->f, s->gc);
@@ -3361,7 +3494,7 @@ x_draw_glyph_string_bg_rect (struct glyph_string *s, int x, int y, int w, int h)
 
       /* Fill background with a stipple pattern.  */
       XSetFillStyle (display, s->gc, FillOpaqueStippled);
-      x_fill_rectangle (s->f, s->gc, x, y, w, h);
+      x_fill_rectangle (s->f, s->gc, x, y, w, h, s->w);
       XSetFillStyle (display, s->gc, FillSolid);
     }
   else
@@ -3567,7 +3700,7 @@ x_draw_stretch_glyph_string (struct glyph_string *s)
 	    {
 	      /* Fill background with a stipple pattern.  */
 	      XSetFillStyle (display, gc, FillOpaqueStippled);
-	      x_fill_rectangle (s->f, gc, x, y, w, h);
+	      x_fill_rectangle (s->f, gc, x, y, w, h, 0);
 	      XSetFillStyle (display, gc, FillSolid);
 	    }
 	  else
@@ -3575,7 +3708,7 @@ x_draw_stretch_glyph_string (struct glyph_string *s)
 	      XGCValues xgcv;
 	      XGetGCValues (display, gc, GCForeground | GCBackground, &xgcv);
 	      XSetForeground (display, gc, xgcv.background);
-	      x_fill_rectangle (s->f, gc, x, y, w, h);
+	      x_fill_rectangle (s->f, gc, x, y, w, h, s->w);
 	      XSetForeground (display, gc, xgcv.foreground);
 	    }
 
@@ -3909,7 +4042,7 @@ x_draw_glyph_string (struct glyph_string *s)
               y = s->ybase + position;
               if (s->face->underline_defaulted_p)
                 x_fill_rectangle (s->f, s->gc,
-                                s->x, y, s->width, thickness);
+                                s->x, y, s->width, thickness, 0);
               else
                 {
                   Display *display = FRAME_X_DISPLAY (s->f);
@@ -3917,7 +4050,7 @@ x_draw_glyph_string (struct glyph_string *s)
                   XGetGCValues (display, s->gc, GCForeground, &xgcv);
                   XSetForeground (display, s->gc, s->face->underline_color);
                   x_fill_rectangle (s->f, s->gc,
-                                  s->x, y, s->width, thickness);
+                                  s->x, y, s->width, thickness, 0);
                   XSetForeground (display, s->gc, xgcv.foreground);
                 }
             }
@@ -3929,7 +4062,7 @@ x_draw_glyph_string (struct glyph_string *s)
 
 	  if (s->face->overline_color_defaulted_p)
 	    x_fill_rectangle (s->f, s->gc, s->x, s->y + dy,
-			    s->width, h);
+			    s->width, h, 0);
 	  else
 	    {
               Display *display = FRAME_X_DISPLAY (s->f);
@@ -3937,7 +4070,7 @@ x_draw_glyph_string (struct glyph_string *s)
 	      XGetGCValues (display, s->gc, GCForeground, &xgcv);
 	      XSetForeground (display, s->gc, s->face->overline_color);
 	      x_fill_rectangle (s->f, s->gc, s->x, s->y + dy,
-			      s->width, h);
+			      s->width, h, 0);
 	      XSetForeground (display, s->gc, xgcv.foreground);
 	    }
 	}
@@ -3959,7 +4092,7 @@ x_draw_glyph_string (struct glyph_string *s)
 
 	  if (s->face->strike_through_color_defaulted_p)
 	    x_fill_rectangle (s->f, s->gc, s->x, glyph_y + dy,
-			    s->width, h);
+			    s->width, h, s->w);
 	  else
 	    {
               Display *display = FRAME_X_DISPLAY (s->f);
@@ -3967,7 +4100,7 @@ x_draw_glyph_string (struct glyph_string *s)
 	      XGetGCValues (display, s->gc, GCForeground, &xgcv);
 	      XSetForeground (display, s->gc, s->face->strike_through_color);
 	      x_fill_rectangle (s->f, s->gc, s->x, glyph_y + dy,
-			      s->width, h);
+			      s->width, h, s->w);
 	      XSetForeground (display, s->gc, xgcv.foreground);
 	    }
 	}
@@ -4061,34 +4194,93 @@ x_delete_glyphs (struct frame *f, int n)
    If they are <= 0, this is probably an error.  */
 
 static ATTRIBUTE_UNUSED void
-x_clear_area1 (Display *dpy, Window window,
+x_clear_area1 (struct window* emacs_window,
+               Display *dpy, Window window,
                int x, int y, int width, int height, int exposures)
 {
   eassert (width > 0 && height > 0);
-  XClearArea (dpy, window, x, y, width, height, exposures);
+  if (bgexi_p (-1))
+    {
+      GC gc;
+
+      gc = XCreateGC (dpy, window, 0, 0);
+
+      if (bgexi_fill_rectangle (gc, emacs_window,
+                                x, y, width, height, 0))
+        {
+          XClearArea (dpy, window, x, y, width, height, exposures);
+        }
+
+      XFreeGC (dpy, gc);
+    }
+  else
+    {
+      if (emacs_window && bgexi_special_trigger_p (emacs_window))
+        {
+          GC gc;
+
+          gc = XCreateGC (dpy, window, 0, 0);
+          bgexi_fill_rectangle (gc, emacs_window,
+                                0, 0, 1, 1, 0);
+          XFreeGC (dpy, gc);
+
+          bgexi_clear_special_trigger_p ();
+        }
+      XClearArea (dpy, window, x, y, width, height, exposures);
+    }
 }
 
 void
-x_clear_area (struct frame *f, int x, int y, int width, int height)
+x_clear_area (struct window* emacs_window, struct frame *f, int x, int y, int width, int height)
 {
 #ifdef USE_CAIRO
   cairo_t *cr;
 
   eassert (width > 0 && height > 0);
 
-  cr = x_begin_cr_clip (f, NULL);
-  x_set_cr_source_with_gc_background (f, f->output_data.x->normal_gc);
-  cairo_rectangle (cr, x, y, width, height);
-  cairo_fill (cr);
-  x_end_cr_clip (f);
+  if (bgexi_p (-1))
+    {
+      x_clear_area1 (emacs_window, FRAME_X_DISPLAY (f), FRAME_X_WINDOW (f),
+		     x, y, width, height, False);
+    }
+  else
+    {
+      cr = x_begin_cr_clip (f, NULL);
+      x_set_cr_source_with_gc_background (f, f->output_data.x->normal_gc);
+      cairo_rectangle (cr, x, y, width, height);
+      cairo_fill (cr);
+      x_end_cr_clip (f);
+    }
 #else
   if (FRAME_X_DOUBLE_BUFFERED_P (f))
-    XFillRectangle (FRAME_X_DISPLAY (f),
-		    FRAME_X_DRAWABLE (f),
-		    f->output_data.x->reverse_gc,
-		    x, y, width, height);
+    {
+      if (bgexi_p (-1))
+        {
+          x_clear_area1 (emacs_window, FRAME_X_DISPLAY (f), FRAME_X_WINDOW (f),
+                         x, y, width, height, False);
+        }
+      else
+        {
+          if (emacs_window && bgexi_special_trigger_p (emacs_window))
+            {
+              struct frame *f = XFRAME (WINDOW_FRAME (emacs_window));
+              GC gc;
+
+              gc = XCreateGC (FRAME_X_DISPLAY (f), FRAME_X_DRAWABLE (f), 0, 0);
+              bgexi_fill_rectangle (gc, emacs_window,
+                                    0, 0, 1, 1, 0);
+              XFreeGC (FRAME_X_DISPLAY (f), gc);
+
+              bgexi_clear_special_trigger_p ();
+            }
+          XFillRectangle (FRAME_X_DISPLAY (f),
+                          FRAME_X_DRAWABLE (f),
+                          f->output_data.x->reverse_gc,
+                          x, y, width, height);
+        }
+    }
   else
-    x_clear_area1 (FRAME_X_DISPLAY (f), FRAME_X_WINDOW (f),
+    x_clear_area1 (emacs_window, FRAME_X_DISPLAY (f), FRAME_X_WINDOW (f),
                    x, y, width, height, False);
 #endif
 }
@@ -4458,12 +4650,27 @@ x_scroll_run (struct window *w, struct run *run)
     }
   else
 #endif	/* USE_CAIRO */
-    XCopyArea (FRAME_X_DISPLAY (f),
-	       FRAME_X_DRAWABLE (f), FRAME_X_DRAWABLE (f),
-	       f->output_data.x->normal_gc,
-	       x, from_y,
-	       width, height,
-	       x, to_y);
+    if (!bgexi_p (-1))
+      {
+        Drawable drawable_a = FRAME_X_DRAWABLE (f);
+        Drawable drawable_b = FRAME_X_DRAWABLE (f);
+        XCopyArea (FRAME_X_DISPLAY (f),
+                   drawable_a, drawable_b,
+                   f->output_data.x->normal_gc,
+                   x, from_y,
+                   width, height,
+                   x, to_y);
+      }
+    else
+      {
+        Emacs_Rectangle r;
+        r.x = 0;
+        r.y = (from_y < to_y) ? from_y : to_y;
+        r.width = width;
+        r.height = height + abs(from_y - to_y);
+        w->must_be_updated_p = 1;
+        expose_window (w, &r);
+      }
 
   unblock_input ();
 }
@@ -6764,7 +6971,7 @@ x_scroll_bar_create (struct window *w, int top, int left,
        for the case that a window has been split horizontally.  In
        this case, no clear_frame is generated to reduce flickering.  */
     if (width > 0 && window_box_height (w) > 0)
-      x_clear_area (f, left, top, width, window_box_height (w));
+      x_clear_area (w, f, left, top, width, window_box_height (w));
 
     window = XCreateWindow (FRAME_X_DISPLAY (f), FRAME_X_WINDOW (f),
 			    /* Position and size of scroll bar.  */
@@ -6900,10 +7107,10 @@ x_scroll_bar_set_handle (struct scroll_bar *bar, int start, int end,
     /* Draw the empty space above the handle.  Note that we can't clear
        zero-height areas; that means "clear to end of window."  */
     if ((inside_width > 0) && (start > 0))
-      x_clear_area1 (FRAME_X_DISPLAY (f), w,
-		    VERTICAL_SCROLL_BAR_LEFT_BORDER,
-		    VERTICAL_SCROLL_BAR_TOP_BORDER,
-		    inside_width, start, False);
+      x_clear_area1 (0, FRAME_X_DISPLAY (f), w,
+                     VERTICAL_SCROLL_BAR_LEFT_BORDER,
+                     VERTICAL_SCROLL_BAR_TOP_BORDER,
+                     inside_width, start, False);
 
     /* Change to proper foreground color if one is specified.  */
     if (f->output_data.x->scroll_bar_foreground_pixel != -1)
@@ -6925,10 +7132,10 @@ x_scroll_bar_set_handle (struct scroll_bar *bar, int start, int end,
     /* Draw the empty space below the handle.  Note that we can't
        clear zero-height areas; that means "clear to end of window." */
     if ((inside_width > 0) && (end < inside_height))
-      x_clear_area1 (FRAME_X_DISPLAY (f), w,
-		    VERTICAL_SCROLL_BAR_LEFT_BORDER,
-		    VERTICAL_SCROLL_BAR_TOP_BORDER + end,
-		    inside_width, inside_height - end, False);
+      x_clear_area1 (0, FRAME_X_DISPLAY (f), w,
+                     VERTICAL_SCROLL_BAR_LEFT_BORDER,
+                     VERTICAL_SCROLL_BAR_TOP_BORDER + end,
+                     inside_width, inside_height - end, False);
   }
 
   unblock_input ();
@@ -6992,7 +7199,7 @@ XTset_vertical_scroll_bar (struct window *w, int portion, int whole, int positio
       if (width > 0 && height > 0)
 	{
 	  block_input ();
-          x_clear_area (f, left, top, width, height);
+          x_clear_area (w, f, left, top, width, height);
 	  unblock_input ();
 	}
 
@@ -7024,7 +7231,7 @@ XTset_vertical_scroll_bar (struct window *w, int portion, int whole, int positio
 	  /* Since toolkit scroll bars are smaller than the space reserved
 	     for them on the frame, we have to clear "under" them.  */
 	  if (width > 0 && height > 0)
-	    x_clear_area (f, left, top, width, height);
+	    x_clear_area (w, f, left, top, width, height);
 #ifdef USE_GTK
           xg_update_scrollbar_pos (f, bar->x_window, top,
 				   left, width, max (height, 1));
@@ -7110,7 +7317,7 @@ XTset_horizontal_scroll_bar (struct window *w, int portion, int whole, int posit
 
 	  /* Clear also part between window_width and
 	     WINDOW_PIXEL_WIDTH.  */
-	  x_clear_area (f, left, top, pixel_width, height);
+	  x_clear_area (w, f, left, top, pixel_width, height);
 	  unblock_input ();
 	}
 
@@ -7141,7 +7348,7 @@ XTset_horizontal_scroll_bar (struct window *w, int portion, int whole, int posit
 	  /* Since toolkit scroll bars are smaller than the space reserved
 	     for them on the frame, we have to clear "under" them.  */
 	  if (width > 0 && height > 0)
-	    x_clear_area (f,
+	    x_clear_area (w, f,
 			  WINDOW_LEFT_EDGE_X (w), top,
 			  pixel_width - WINDOW_RIGHT_DIVIDER_WIDTH (w), height);
 #ifdef USE_GTK
@@ -7162,7 +7369,7 @@ XTset_horizontal_scroll_bar (struct window *w, int portion, int whole, int posit
 	int area_height = WINDOW_CONFIG_SCROLL_BAR_HEIGHT (w);
 	int rest = area_height - height;
 	if (rest > 0 && width > 0)
-	  x_clear_area (f, left, top, width, rest);
+	  x_clear_area (w, f, left, top, width, rest);
       }
 
       /* Move/size the scroll bar window.  */
@@ -8244,6 +8451,7 @@ handle_one_xevent (struct x_display_info *dpyinfo,
                  the frame, so we'll redraw the whole thing on next
                  redisplay anyway.  Yuck.  */
               x_clear_area1 (
+                0,
                 FRAME_X_DISPLAY (f),
                 FRAME_X_WINDOW (f),
                 event->xexpose.x, event->xexpose.y,
@@ -8259,7 +8467,7 @@ handle_one_xevent (struct x_display_info *dpyinfo,
 #ifdef USE_GTK
               /* This seems to be needed for GTK 2.6 and later, see
                  https://debbugs.gnu.org/cgi/bugreport.cgi?bug=15398.  */
-              x_clear_area (f,
+              x_clear_area (0, f,
                             event->xexpose.x, event->xexpose.y,
                             event->xexpose.width, event->xexpose.height);
 #endif
@@ -9626,7 +9834,7 @@ x_draw_bar_cursor (struct window *w, struct glyph_row *row, int width, enum text
 
 	  x_fill_rectangle (f, gc, x,
 			  WINDOW_TO_FRAME_PIXEL_Y (w, w->phys_cursor.y),
-			  width, row->height);
+			    width, row->height, w);
 	}
       else /* HBAR_CURSOR */
 	{
@@ -9647,7 +9855,7 @@ x_draw_bar_cursor (struct window *w, struct glyph_row *row, int width, enum text
 	  x_fill_rectangle (f, gc, x,
 			    WINDOW_TO_FRAME_PIXEL_Y (w, w->phys_cursor.y +
                                                      row->height - width),
-                            w->phys_cursor_width - 1, width);
+                            w->phys_cursor_width - 1, width, w);
 	}
 
       x_reset_clip_rectangles (f, gc);
@@ -9670,9 +9878,9 @@ x_define_frame_cursor (struct frame *f, Emacs_Cursor cursor)
 /* RIF: Clear area on frame F.  */
 
 static void
-x_clear_frame_area (struct frame *f, int x, int y, int width, int height)
+x_clear_frame_area (struct window *w, struct frame *f, int x, int y, int width, int height)
 {
-  x_clear_area (f, x, y, width, height);
+  x_clear_area (w, f, x, y, width, height);
 }
 
 
diff --git a/src/xterm.h b/src/xterm.h
index ebc42b7dd5..11af14d0d3 100644
--- a/src/xterm.h
+++ b/src/xterm.h
@@ -1099,7 +1099,7 @@ #define SELECTION_EVENT_TIME(eventp)	\
 #endif
 extern bool x_alloc_nearest_color (struct frame *, Colormap, XColor *);
 extern void x_query_colors (struct frame *f, XColor *, int);
-extern void x_clear_area (struct frame *f, int, int, int, int);
+extern void x_clear_area (struct window*, struct frame *f, int, int, int, int);
 #if !defined USE_X_TOOLKIT && !defined USE_GTK
 extern void x_mouse_leave (struct x_display_info *);
 #endif
